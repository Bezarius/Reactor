<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <title>README.md - Grip</title>
  <link rel="icon" href="http://localhost:6419/__/grip/static/favicon.ico">
  <link rel="stylesheet" href="ReadMe_files/github-6603a12316e50e603e0b44558adf7a5eb8cac166d102d798149c5.css">
  <link rel="stylesheet" href="ReadMe_files/github2-5f7255544b25f937224217b1c37ee5c139a0a00a3decd8020b9a.css">
  <style>
    /* Page tweaks */
    .preview-page {
      margin-top: 64px;
    }
    /* Discussion tweaks */
    .discussion-timeline.wide {
      width: 920px;
    }
    .timeline-comment-wrapper > .timeline-comment:after,
    .timeline-comment-wrapper > .timeline-comment:before {
      content: none;
    }
  </style>
</head>
<body>
  <div id="dic_bubble" class="selection_bubble fontSize13 noSelect" style="z-index: 9999; border: 1px solid rgb(74, 174, 222); visibility: hidden;"></div><div class="page">
    <div id="preview-page" class="preview-page" data-autorefresh-url="/__/grip/refresh/">
    <div class="container">
      
      
      <div class="repository-with-sidebar repo-container with-full-navigation">

        
          <div class="repository-content">
            <div id="readme" class="boxed-group flush clearfix announce instapaper_body md">
              
                <h3>
                  <span class="octicon octicon-book"></span>
                  README.md - Grip
                </h3>
              
              <div id="grip-content" class="markdown-body entry-content">
                <p><a href="http://localhost:6419/UnityProject/Assets/Zenject/Documentation/Images/ZenjectLogo.png?raw=true" target="_blank"><img src="ReadMe_files/ZenjectLogo.png" alt="Zenject" style="max-width:100%;" height="134px" width="600px"></a></p>

<h2>
<a id="user-content-dependency-injection-framework-for-unity3d" class="anchor" href="#dependency-injection-framework-for-unity3d" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dependency Injection Framework for Unity3D</h2>

<h4>
<a id="user-content------new------if-you-like-zenject-you-may-also-be-interested-in-projeny-our-other-open-source-project" class="anchor" href="#-----new------if-you-like-zenject-you-may-also-be-interested-in-projeny-our-other-open-source-project" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>----[ NEW ]---- If you like Zenject, you may also be interested in <a href="https://github.com/modesttree/projeny">Projeny</a> (our other open source project)</h4>

<h3>
<a id="user-content-note" class="anchor" href="#note" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>NOTE</h3>

<p>The following documentation is written to be packaged with Zenject as it appears in the Asset store (which you can find <a href="http://u3d.as/content/modest-tree-media/zenject-dependency-injection/7ER">here</a>)</p>

<h2>
<a id="user-content-introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-introduction"></a>Introduction</h2>

<p>Zenject is a lightweight dependency injection framework built 
specifically to target Unity 3D.  It can be used to turn your Unity 3D 
application into a collection of loosely-coupled parts with highly 
segmented responsibilities.  Zenject can then glue the parts together in
 many different configurations to allow you to easily write, re-use, 
refactor and test your code in a scalable and extremely flexible way.</p>

<p>Tested in Unity 3D on the following platforms: PC/Mac/Linux, iOS, Android, WP8, Webplayer and WebGL (See <a href="#aot-support">here</a> for details on WebGL).</p>

<p>This project is open source.  You can find the official repository <a href="https://github.com/modesttree/Zenject">here</a>.</p>

<p>For general troubleshooting / support, please use the <a href="http://www.reddit.com/r/zenject">zenject subreddit</a> or the <a href="https://groups.google.com/forum/#%21forum/zenject/">zenject google group</a>.  If you have found a bug, you are also welcome to create an issue on the <a href="https://github.com/modesttree/Zenject">github page</a>, or a pull request if you have a fix / extension.  You can also follow <a href="https://twitter.com/Zenject">@Zenject</a> on twitter for updates.  Finally, you can also email me directly at <a href="mailto:sfvermeulen@gmail.com">sfvermeulen@gmail.com</a></p>

<p><strong>Quick Start</strong>:  If you are already familiar with 
dependency injection and are more interested in the syntax than anything
 else, you might want to start by looking over the <a href="#cheatsheet">cheatsheet</a>
 at the bottom of this page, which shows a bunch of typical example 
cases of usage.  You may also be interested in reading some of the Unit 
tests (see <code>Zenject/OptionalExtras/UnitTests</code> directory)</p>

<h2>
<a id="user-content-table-of-contents" class="anchor" href="#table-of-contents" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Table Of Contents</h2>

<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#features">Features</a></li>
<li><a href="#history">History</a></li>
<li>Dependency Injection

<ul>
<li><a href="#theory">Theory</a></li>
<li><a href="#misconceptions">Misconceptions</a></li>
</ul>
</li>
<li>Zenject API

<ul>
<li>
<a href="#overview-of-the-zenject-api">Overview of the Zenject API</a>

<ul>
<li><a href="#hello-world-example">Hello World Example</a></li>
<li><a href="#binding">Binding</a></li>
<li><a href="#inject-methods">Inject Methods</a></li>
<li><a href="#bind-methods">Bind Methods</a></li>
<li><a href="#list-bindings">List Bindings</a></li>
<li><a href="#optional-binding">Optional Binding</a></li>
<li><a href="#identifiers">Identifiers</a></li>
<li><a href="#conditional-bindings">Conditional Bindings</a></li>
<li><a href="#itickable">ITickable</a></li>
<li><a href="#iinitializable-and-postinject">IInitializable and PostInject</a></li>
<li><a href="#implementing-idisposable">Implementing IDisposable</a></li>
<li><a href="#installers">Installers</a></li>
</ul>
</li>
<li><a href="#zenject-order-of-operations">Zenject Order Of Operations</a></li>
<li><a href="#di-guidelines--recommendations">Guidelines / Recommendations / Gotchas / Miscellaneous Tips and Tricks</a></li>
<li>Advanced Features

<ul>
<li><a href="#global-bindings">Global Bindings</a></li>
<li><a href="#update--initialization-order">Update Order And Initialization Order</a></li>
<li><a href="#object-graph-validation">Object Graph Validation</a></li>
<li><a href="#creating-objects-dynamically">Creating Objects Dynamically</a></li>
<li><a href="#using-the-unity-inspector-to-configure-settings">Using the Unity Inspector To Configure Settings</a></li>
<li><a href="#game-object-factories">Game Object Factories</a></li>
<li><a href="#abstract-factories">Abstract Factories</a></li>
<li><a href="#custom-factories">Custom Factories</a></li>
<li><a href="#injecting-data-across-scenes">Injecting Data Across Scenes</a></li>
<li><a href="#scenes-decorator">Scenes Decorators</a></li>
<li><a href="#advanced-factory-construction-using-subcontainers">Advanced Factory Construction Using SubContainers</a></li>
<li><a href="#sub-containers-and-facades">Sub-Containers and Facades</a></li>
<li><a href="#commands-and-signals">Commands And Signals</a></li>
<li><a href="#autobind">Automatic Bindings</a></li>
<li><a href="#auto-mocking-using-moq">Auto-Mocking Using Moq</a></li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#questions">Frequently Asked Questions</a>

<ul>
<li><a href="#aot-support">Does this work on AOT platforms such as iOS and WebGL?</a></li>
<li><a href="#faq-performance">How is Performance?</a></li>
<li><a href="#net-framework">Can I use .NET framework 4.0 and above?</a></li>
</ul>
</li>
<li><a href="#cheatsheet">Cheat Sheet</a></li>
<li><a href="#further-help">Further Help</a></li>
<li><a href="#release-notes">Release Notes</a></li>
<li><a href="#license">License</a></li>
</ul>

<h2>
<a id="user-content-features" class="anchor" href="#features" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-features"></a>Features</h2>

<ul>
<li>Injection into normal C# classes or MonoBehaviours</li>
<li>Constructor injection (can tag constructor if there are multiple)</li>
<li>Field injection</li>
<li>Property injection</li>
<li>Injection via [PostInject] method parameters</li>
<li>Conditional binding (eg. by type, by name, etc.)</li>
<li>Optional dependencies</li>
<li>Support for building dynamic object graphs at runtime using factories</li>
<li>Injection across different Unity scenes</li>
<li>Support for global, project-wide bindings to add dependencies for all scenes</li>
<li>"Scene Decorators" which allow adding functionality to a different scene without changing it directly</li>
<li>Ability to validate object graphs at editor time including dynamic object graphs created via factories</li>
<li>Nested Containers aka Sub-Containers</li>
<li>Support for Commands and Signals</li>
<li>Ability to easily define discrete 'islands' of dependencies using 'Facade' classes</li>
<li>Ability to automatically add bindings by dropping <code>ZenjectAutoBinding</code> on a game object in your scene</li>
<li>Auto-Mocking using the Moq library</li>
</ul>

<h2>
<a id="user-content-history" class="anchor" href="#history" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-history"></a>History</h2>

<p>Unity is a fantastic game engine, however the approach that new 
developers are encouraged to take does not lend itself well to writing 
large, flexible, or scalable code bases.  In particular, the default way
 that Unity manages dependencies between different game components can 
often be awkward and error prone.</p>

<p>Having worked on non-unity projects that use dependency management 
frameworks (such as Ninject, which Zenject takes a lot of inspiration 
from), the problem irked me enough that I decided a custom framework was
 necessary.</p>

<p>Upon googling for solutions, I found a <a href="http://blog.sebaslab.com/ioc-container-for-unity3d-part-1/">series of great articles</a>
 by Sebastiano Mandalà outlining the problem.  Sebastiano even wrote a 
proof of concept and open sourced it, which became the basis for this 
library.</p>

<p>What follows in the next section is a general overview of Dependency 
Injection from my perspective.  I highly recommend seeking other 
resources for more information on the subject, as there are many (often 
more intelligent) people that have written on the subject.  In 
particular, I highly recommend anything written by Mark Seeman on the 
subject - in particular his book 'Dependency Injection in .NET'.</p>

<p>Finally, I will just say that if you don't have experience with DI 
frameworks, and are writing object oriented code, then trust me, you 
will thank me later!  Once you learn how to write properly loosely 
coupled code using DI, there is simply no going back.</p>

<h2>
<a id="user-content-theory" class="anchor" href="#theory" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-theory"></a>Theory</h2>

<p>See <a href="https://www.youtube.com/watch?v=8ZCkEXv3QsQ">here</a> for a video that also serves as a nice introduction to the theory.</p>

<p>When writing an individual class to achieve some functionality, it 
will likely need to interact with other classes in the system to achieve
 its goals.  One way to do this is to have the class itself create its 
dependencies, by calling concrete constructors:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>
{
    ISomeService _service;

    <span class="pl-k">public</span> <span class="pl-en">Foo</span>()
    {
        _service = <span class="pl-k">new</span> SomeService();
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">DoSomething</span>()
    {
        _service.PerformTask();
        ...
    }
}</pre></div>

<p>This works fine for small projects, but as your project grows it 
starts to get unwieldy.  The class Foo is tightly coupled to class 
'SomeService'.  If we decide later that we want to use a different 
concrete implementation then we have to go back into the Foo class to 
change it.</p>

<p>After thinking about this, often you come to the realization that 
ultimately, Foo shouldn't bother itself with the details of choosing the
 specific implementation of the service.  All Foo should care about is 
fulfilling its own specific responsibilities.  As long as the service 
fulfills the abstract interface required by Foo, Foo is happy.  Our 
class then becomes:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>
{
    ISomeService _service;

    <span class="pl-k">public</span> <span class="pl-en">Foo</span>(<span class="pl-k">ISomeService</span> <span class="pl-smi">service</span>)
    {
        _service = service;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">DoSomething</span>()
    {
        _service.PerformTask();
        ...
    }
}</pre></div>

<p>This is better, but now whatever class is creating Foo (let's call it
 Bar) has the problem of filling in Foo's extra dependencies:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Bar</span>
{
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">DoSomething</span>()
    {
        <span class="pl-k">var</span> foo = <span class="pl-k">new</span> Foo(<span class="pl-k">new</span> SomeService());
        foo.DoSomething();
        ...
    }
}</pre></div>

<p>And class Bar probably also doesn't really care about what specific 
implementation of SomeService Foo uses.  Therefore we push the 
dependency up again:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Bar</span>
{
    ISomeService _service;

    <span class="pl-k">public</span> <span class="pl-en">Bar</span>(<span class="pl-k">ISomeService</span> <span class="pl-smi">service</span>)
    {
        _service = service;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">DoSomething</span>()
    {
        <span class="pl-k">var</span> foo = <span class="pl-k">new</span> Foo(_service);
        foo.DoSomething();
        ...
    }
}</pre></div>

<p>So we find that it is useful to push the responsibility of deciding 
which specific implementations of which classes to use further and 
further up in the 'object graph' of the application.  Taking this to an 
extreme, we arrive at the entry point of the application, at which point
 all dependencies must be satisfied before things start.  The dependency
 injection lingo for this part of the application is called the 
'composition root'.</p>

<h2>
<a id="user-content-misconceptions" class="anchor" href="#misconceptions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-misconceptions"></a>Misconceptions</h2>

<p>There are many misconceptions about DI, due to the fact that it can 
be tricky to fully wrap your head around at first.  It will take time 
and experience before it fully 'clicks'.</p>

<p>As shown in the above example, DI can be used to easily swap 
different implementations of a given interface (in the example this was 
ISomeService).  However, this is only one of many benefits that DI 
offers.</p>

<p>More important than that is the fact that using a dependency 
injection framework like Zenject allows you to more easily follow the '<a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a>'.
  By letting Zenject worry about wiring up the classes, the classes 
themselves can just focus on fulfilling their specific responsibilities.</p>

<p>Another common mistake that people new to DI make is that they 
extract interfaces from every class, and use those interfaces everywhere
 instead of using the class directly.  The goal is to make code more 
loosely coupled, so it's reasonable to think that being bound to an 
interface is better than being bound to a concrete class.  However, in 
most cases the various responsibilities of an application have single, 
specific classes implementing them, so using an interfaces in these 
cases just adds unnecessary maintenance overhead.  Also, concrete 
classes already have an interface defined by their public members.  A 
good rule of thumb instead is to only create interfaces when the class 
has more than one implementation.  This is known, by the way, as the <a href="http://codemanship.co.uk/parlezuml/blog/?postid=934">Reused Abstraction Principle</a>)</p>

<p>Other benefits include:</p>

<ul>
<li>Testability - Writing automated unit tests or user-driven tests 
becomes very easy, because it is just a matter of writing a different 
'composition root' which wires up the dependencies in a different way.  
Want to only test one subsystem?  Simply create a new composition root. 
 Zenject also has some support for avoiding code duplication in the 
composition root itself (using Installers - described below). In cases 
where you can't easily separate out a specific sub-system to test, you 
can also creates 'mocks' for the sub-systems that you don't care about. 
(more detail <a href="#auto-mocking-using-moq">below</a>)</li>
<li>Refactorability - When code is loosely coupled, as is the case when 
using DI properly, the entire code base is much more resilient to 
changes.  You can completely change parts of the code base without 
having those changes wreak havoc on other parts.</li>
<li>Encourages modular code - When using a DI framework you will 
naturally follow better design practices, because it forces you to think
 about the interfaces between classes.</li>
</ul>

<h2>
<a id="user-content-overview-of-the-zenject-api" class="anchor" href="#overview-of-the-zenject-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-overview-of-the-zenject-api"></a>Overview Of The Zenject API</h2>

<p>What follows is a general overview of how DI patterns are applied 
using Zenject.  For further documentation I highly recommend the sample 
project itself (a kind of asteroids clone, which you can find by opening
 "Zenject/OptionalExtras/SampleGame/Asteroids.unity").  I would 
recommend using that for reference after reading over these concepts.</p>

<p>You may also find the <a href="#cheatsheet">cheatsheet</a> at the bottom of this page helpful in understanding some typical usage scenarios.</p>

<p>The unit tests may also be helpful to show usage for each specific feature (which you can find at <code>Zenject/OptionalExtras/UnitTests</code>)</p>

<h2>
<a id="user-content-hello-world-example" class="anchor" href="#hello-world-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-hello-world-example"></a>Hello World Example</h2>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">using</span> Zenject<span class="pl-k">;</span>
<span class="pl-k">using</span> UnityEngine<span class="pl-k">;</span>
<span class="pl-k">using</span> System.Collections<span class="pl-k">;</span>

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">TestInstaller</span> : <span class="pl-k">MonoInstaller</span>
{
    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">InstallBindings</span>()
    {
        Container.Bind&lt;ITickable&gt;().ToSingle&lt;TestRunner&gt;();
        Container.Bind&lt;IInitializable&gt;().ToSingle&lt;TestRunner&gt;();
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">TestRunner</span> : <span class="pl-k">ITickable</span>, <span class="pl-k">IInitializable</span>
{
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Initialize</span>()
    {
        Debug.Log(<span class="pl-s"><span class="pl-pds">"</span>Hello World<span class="pl-pds">"</span></span>);
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Tick</span>()
    {
        <span class="pl-k">if</span> (Input.GetKeyDown(KeyCode.Space))
        {
            Debug.Log(<span class="pl-s"><span class="pl-pds">"</span>Exiting!<span class="pl-pds">"</span></span>);
            Application.Quit();
        }
    }
}</pre></div>

<p>You can run this example by doing the following:</p>

<ul>
<li>Copy and paste the above code into a file named 'TestInstaller'</li>
<li>Create a new scene in Unity</li>
<li>Right Click inside the Hierarchy tab and select Zenject -&gt; Scene Composition Root</li>
<li>Add your TestInstaller script to the scene as well (as its own 
GameObject or on the same GameObject as the CompositionRoot, it doesn't 
matter)</li>
<li>Add a reference to your TestInstaller to the properties of the 
CompositionRoot by adding a new row in the inspector of the "Installers"
 property (Increase "Size" to 1) and then dragging the TestInstaller 
GameObject to it</li>
<li>Validate your scene by either selecting Edit -&gt; Zenject -&gt; 
Validate Current Scene or hitting CTRL+SHIFT+V.  (note that this step 
isn't necessary but good practice to get into)</li>
<li>Run</li>
<li>Observe unity console for output</li>
</ul>

<p>The CompositionRoot MonoBehaviour is the entry point of the 
application, where Zenject sets up all the various dependencies before 
kicking off your scene.  To add content to your Zenject scene, you need 
to write what is referred to in Zenject as an 'Installer', which 
declares all the dependencies used in your scene and their relationships
 with each other.  If the above doesn't make sense to you yet, keep 
reading!</p>

<h2>
<a id="user-content-binding" class="anchor" href="#binding" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-binding"></a>Binding</h2>

<p>Every dependency injection framework is ultimately just a framework to bind types to instances.</p>

<p>In Zenject, dependency mapping is done by adding bindings to 
something called a container.  The container should then 'know' how to 
create all the object instances in our application, by recursively 
resolving all dependencies for a given object.</p>

<p>When the container is asked to construct an instance of a given type,
 it uses C# reflection to find the list of constructor arguments, and 
all fields/properties that are marked with an [Inject] attribute.  It 
then attempts to resolve each of these required dependencies, which it 
uses to call the constructor and create the new instance.</p>

<p>Each Zenject application therefore must tell the container how to 
resolve each of these dependencies, which is done via Bind commands.  
For example, given the following class:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>
{
    IBar _bar;

    <span class="pl-k">public</span> <span class="pl-en">Foo</span>(<span class="pl-k">IBar</span> <span class="pl-smi">bar</span>)
    {
        _bar = bar;
    }
}</pre></div>

<p>You can wire up the dependencies for this class with the following bindings:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;Foo&gt;().ToSingle();
Container.Bind&lt;IBar&gt;().ToSingle&lt;Bar&gt;();</pre></div>

<p>This tells Zenject that every class that requires a dependency of 
type Foo should use the same instance, which it will automatically 
create when needed.  And similarly, any class that requires the IBar 
interface (like Foo) will be given the same instance of type Bar.</p>

<h2>
<a id="user-content-inject-methods" class="anchor" href="#inject-methods" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-inject-methods"></a>Inject Methods</h2>

<p>There are many different ways of binding types on the container, which are documented in the <a href="#bind-methods">next section</a>.  There are also several ways of having these dependencies injected into your classes. These are:</p>

<p>1 - <strong>Constructor Injection</strong></p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>
{
    IBar _bar;

    <span class="pl-k">public</span> <span class="pl-en">Foo</span>(<span class="pl-k">IBar</span> <span class="pl-smi">bar</span>)
    {
        _bar = bar;
    }
}</pre></div>

<p>Here, the IBar dependency is injected via the constructor.</p>

<p>2 - <strong>Field Injection</strong></p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>
{
    [Inject]
    IBar _bar;
}</pre></div>

<p>Field injection occurs immediately after the constructor is called.  
All fields that are marked with the [Inject] attribute are looked up in 
the container and given a value.  Note that these fields can be private 
or public and injection will still occur.</p>

<p>3 - <strong>Property Injection</strong></p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>
{
    [Inject]
    <span class="pl-k">public</span> IBar Bar
    {
        <span class="pl-k">get</span>;
        <span class="pl-k">private</span> <span class="pl-k">set</span>;
    }
}</pre></div>

<p>Property injection works the same as field injection except is 
applied to C# properties.  Just like fields, the setter can be private 
or public in this case.</p>

<p>4 - <strong>PostInject Injection</strong></p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>
{
    IBar _bar;

    [PostInject]
    <span class="pl-k">public</span> <span class="pl-en">Init</span>(<span class="pl-k">IBar</span> <span class="pl-smi">bar</span>)
    {
        _bar = bar;
    }
}</pre></div>

<p>PostInject injection works very similar to constructor injection.  
The PostInject methods are called after all other dependencies have been
 resolved, and can be used to execute initialization logic.  Unlike 
constructor injection, PostInject methods can make use of any fields 
that are marked as [Inject] because all other injection methods are 
guaranteed to have completed before the PostInject methods are called.</p>

<p>You may also pass dependencies in as parameters to the PostInject method similar to how constructor injection works.</p>

<p>Note that there can be any number of PostInject methods.  In this 
case, they are called in the order of Base class to Derived class.  This
 can be useful to avoid the need to forward many dependencies from 
derived classes to the base class via constructor parameters, while also
 guaranteeing that the base class PostInject completes first, just like 
how constructors work.</p>

<p>Using [PostInject] to inject dependencies is the recommended approach
 for MonoBehaviours, since MonoBehaviours cannot have constructors.</p>

<p><strong>Recommendations</strong></p>

<ul>
<li>Best practice is to prefer constructor injection or [PostInject] injection to field or property injection.

<ul>
<li>Constructor/[PostInject] injection forces the dependency to only be 
resolved once, at class creation, which is usually what you want.  In 
many cases you don't want to expose a public property with your internal
 dependencies (although you can also [Inject] on private 
fields/properties)</li>
<li>Constructor injection guarantees no circular dependencies between 
classes, which is generally a bad thing to do.  You can do this however 
using [PostInject] or field injection if necessary.</li>
<li>Constructor/[PostInject] injection is more portable for cases where 
you decide to re-use the code without a DI framework such as Zenject.  
You can do the same with public properties but it's more error prone 
(it's easier to forget to initialize one field and leave the object in 
an invalid state)</li>
<li>Finally, Constructor/[PostInject] injection makes it clear what all 
the dependencies of a class are when another programmer is reading the 
code.  They can simply look at the parameter list of the method.</li>
</ul>
</li>
</ul>

<h2>
<a id="user-content-bind-methods" class="anchor" href="#bind-methods" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-bind-methods"></a>Bind Methods</h2>

<p>See the <a href="#binding">binding section</a> above for a general overview of binding.  The format for the bind command can be any of the following:</p>

<p>Note that you can find more examples in the <a href="#cheatsheet">cheatsheet</a> section below.</p>

<p>1 - <strong>ToSingle</strong> - Inject as singleton</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;Foo&gt;().ToSingle();</pre></div>

<p>When a type is bound using ToSingle this will construct one and only 
one instance of Foo and use that everywhere that has Foo as a dependency</p>

<p>You may also bind the singleton instance to one or more interfaces:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo&gt;();
Container.Bind&lt;IBar&gt;().ToSingle&lt;Foo&gt;();</pre></div>

<p>This will cause any dependencies of type IFoo or IBar to use the same
 instance of Foo.  Of course, Foo must implement both IFoo and IBar for 
this to compile.  However, with only the above two lines the Foo 
singleton will not be accessible directly.  You can achieve this by 
using another line to uses ToSingle directly:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;Foo&gt;().ToSingle();
Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo&gt;();
Container.Bind&lt;IBar&gt;().ToSingle&lt;Foo&gt;();</pre></div>

<p>Note again that the same instance will be used for all dependencies that take Foo, IFoo, or IBar.</p>

<p>2 - <strong>ToInstance</strong> - Inject as a specific instance</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;Foo&gt;().ToInstance(<span class="pl-k">new</span> Foo());
Container.Bind&lt;<span class="pl-k">string</span>&gt;().ToInstance(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>);
Container.Bind&lt;<span class="pl-k">int</span>&gt;().ToInstance(<span class="pl-c1">42</span>);

<span class="pl-c">// Or with shortcut:</span>
Container.BindInstance(<span class="pl-k">new</span> Bar());</pre></div>

<p>In this case the given instance will be used for every dependency with the given type</p>

<p>3 - <strong>ToTransient</strong> - Inject as newly created object</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;Foo&gt;().ToTransient();</pre></div>

<p>In this case a new instance of Foo will be generated each time it is 
injected. Similar to ToSingle, you can bind via an interface as well:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFoo&gt;().ToTransient&lt;Foo&gt;();</pre></div>

<p>4 - <strong>ToSinglePrefab</strong> - Inject by instantiating a unity prefab once and using that everywhere</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;FooMonoBehaviour&gt;().ToSinglePrefab(PrefabGameObject);</pre></div>

<p>This will instantiate a new instance of the given prefab, and then 
search the newly created game object for the given component (in this 
case FooMonoBehaviour).</p>

<p>Also, because it is ToSingle it will only instantiate the prefab once, and otherwise use the same instance of FooMonoBehaviour.</p>

<p>You can also bind multiple singletons to the same prefab.  For example:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;FooMonoBehaviour&gt;().ToSinglePrefab(PrefabGameObject);
Container.Bind&lt;BarMonoBehaviour&gt;().ToSinglePrefab(PrefabGameObject);</pre></div>

<p>This will result in the prefab <code>PrefabGameObject</code> being instantiated once, and then searched for monobehaviour's <code>FooMonoBehaviour</code> and <code>BarMonoBehaviour</code></p>

<p>5 - <strong>ToSinglePrefabResource</strong> - Load prefab via resources folder</p>

<p>Same as ToSinglePrefab except loads the prefab using a path in Resources folder</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;FooMonoBehaviour&gt;().ToSinglePrefabResource(<span class="pl-s"><span class="pl-pds">"</span>MyDirectory/MyPrefab<span class="pl-pds">"</span></span>);</pre></div>

<p>In this example, I've placed my prefab at 
Assets/Resources/MyDirectory/MyPrefab.prefab.  By doing this I don't 
have to pass in a GameObject and can refer to it by the path within the 
resources folder.</p>

<p>Note that you can re-use the same singleton instance for multiple monobehaviours that exist on the prefab.</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;FooMonoBehaviour&gt;().ToSinglePrefabResource(<span class="pl-s"><span class="pl-pds">"</span>MyDirectory/MyPrefab<span class="pl-pds">"</span></span>);
Container.Bind&lt;BarMonoBehaviour&gt;().ToSinglePrefabResource(<span class="pl-s"><span class="pl-pds">"</span>MyDirectory/MyPrefab<span class="pl-pds">"</span></span>);</pre></div>

<p>In the above example, the prefab will only be instantiated once.</p>

<p>6 - <strong>ToTransientPrefab</strong> - Inject by instantiating a unity prefab each time</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;FooMonoBehaviour&gt;().ToTransientPrefab(PrefabGameObject);</pre></div>

<p>This works similar to ToSinglePrefab except it will instantiate a new
 instance of the given prefab every time the dependency is injected.</p>

<p>7 - <strong>ToTransientPrefabResource</strong> - Load prefab via resources folder</p>

<p>Same as ToTransientPrefab except loads the prefab using a path in Resources folder</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;FooMonoBehaviour&gt;().ToTransientPrefabResource(<span class="pl-s"><span class="pl-pds">"</span>MyDirectory/MyPrefab<span class="pl-pds">"</span></span>);</pre></div>

<p>In the above example, I've placed my prefab at 
Assets/Resources/MyDirectory/MyPrefab.prefab.  By doing this I don't 
have to pass in a GameObject and can refer to it by the path within the 
resources folder.</p>

<p>8 - <strong>ToSingleGameObject</strong> - Inject by instantiating a new game object and using that everywhere</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;FooMonoBehaviour&gt;().ToSingleGameObject();</pre></div>

<p>This binding will create a new game object and attach the given 
FooMonoBehaviour.  Also note that since it is ToSingle that it will use 
the same instance everywhere that has FooMonoBehaviour as a dependency</p>

<p>9 - <strong>ToTransientGameObject</strong> - Inject by instantiating a new game object</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;FooMonoBehaviour&gt;().ToTransientGameObject();</pre></div>

<p>This binding will create a new game object and attach the given 
FooMonoBehaviour.  Note that since this is transient, a unique game 
object will be created every time it is injected.</p>

<p>10 - <strong>ToMethod</strong> - Inject using a custom method</p>

<p>This binding allows you to customize creation logic yourself by defining a method:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFoo&gt;().ToMethod(SomeMethod);</pre></div>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> IFoo SomeMethod(InjectContext context)
{
    ...
    <span class="pl-k">return</span> <span class="pl-k">new</span> Foo();
}</pre></div>

<p>11 - <strong>ToSingleMethod</strong> - Inject using a custom method but only call that method once</p>

<p>This binding works similar to <code>ToMethod</code> except that the 
given method will only be called once.  The value returned from the 
method will then be used for every subsequent request for the given 
dependency.</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFoo&gt;().ToSingleMethod(SomeMethod);</pre></div>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> IFoo SomeMethod(InjectContext context)
{
    ...
    <span class="pl-k">return</span> <span class="pl-k">new</span> Foo();
}</pre></div>

<p>12 - <strong>ToGetter</strong> - Inject by getter.</p>

<p>This method can be useful if you want to bind to a property of another object.</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo&gt;()
Container.Bind&lt;Bar&gt;().ToGetter&lt;IFoo&gt;(x =&gt; x.GetBar())</pre></div>

<p>13 - <strong>ToLookup</strong> - Inject by recursive resolve.</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFoo&gt;().ToLookup&lt;IBar&gt;()
Container.Bind&lt;IBar&gt;().ToLookup&lt;Foo&gt;()</pre></div>

<p>In some cases it is useful to be able to bind an interface to another
 interface.  However, you cannot use ToSingle or ToTransient because 
they both require concrete types.</p>

<p>In the example code above we assume that Foo inherits from IBar, 
which inherits from IFoo.  The result here will be that all dependencies
 for IFoo will be bound to whatever IBar is bound to (in this case, 
Foo).</p>

<p>You can also supply an identifier to the ToLookup() method.  See <a href="#identifiers">here</a> section for details on identifiers.</p>

<p>14 - <strong>Rebind</strong> - Override existing binding</p>

<div class="highlight highlight-source-cs"><pre>Container.Rebind&lt;IFoo&gt;().To&lt;Foo&gt;();</pre></div>

<p>The Rebind function can be used to override any existing bindings 
that were added previously.  It will first clear all previous bindings 
and then add the new binding.  This method is especially useful for 
tests, where you often want to use almost all the same bindings used in 
production, except override a few specific bindings.</p>

<p>15 - <strong>BindAllInterfacesToSingle</strong></p>

<p>This function can be used to automatically bind any interfaces that it finds on the given type.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span> : <span class="pl-k">ITickable</span>, <span class="pl-k">IInitializable</span>
{
    ...
}

...

Container.Bind&lt;Foo&gt;().ToSingle();
Container.BindAllInterfacesToSingle&lt;Foo&gt;();</pre></div>

<p>The above is equivalent to the following:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;Foo&gt;().ToSingle();
Container.Bind&lt;ITickable&gt;().ToSingle&lt;Foo&gt;();
Container.Bind&lt;IInitializable&gt;().ToSingle&lt;Foo&gt;();</pre></div>

<p>16 - <strong>BindAllInterfacesToInstance</strong></p>

<p>This function works very similar to BindAllInterfacesToSingle.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span> : <span class="pl-k">ITickable</span>, <span class="pl-k">IInitializable</span>
{
    ...
}

...

Container.BindAllInterfacesToInstance(<span class="pl-k">new</span> Foo());</pre></div>

<p>The above is equivalent to the following:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> foo = <span class="pl-k">new</span> Foo();
Container.Bind&lt;ITickable&gt;().ToInstance(foo);
Container.Bind&lt;IInitializable&gt;().ToInstance(foo);</pre></div>

<p>17 - <strong>ToSingleInstance</strong> - Use the given instance as a singleton.</p>

<p>This is the same as <code>ToInstance</code> except it will ensure that there is only ever one instance for the given type.</p>

<p>When using <code>ToInstance</code> you can do the following:</p>

<pre><code>Container.Bind&lt;Foo&gt;().ToInstance(new Foo());
Container.Bind&lt;Foo&gt;().ToInstance(new Foo());
Container.Bind&lt;Foo&gt;().ToInstance(new Foo());
</code></pre>

<p>Or, equivalently:</p>

<pre><code>Container.BindInstance(new Foo());
Container.BindInstance(new Foo());
Container.BindInstance(new Foo());
</code></pre>

<p>And then have a class that takes all of them as a list like this:</p>

<pre><code>public class Bar
{
    public Bar(List&lt;Foo&gt; foos)
    {
    }
}
</code></pre>

<p>Whereas, if you use ToSingleInstance this would trigger an error.</p>

<p>18 - <strong>ToSingleFactory</strong> - Define a custom factory for a singleton</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFoo&gt;().ToSingleFactory&lt;MyCustomFactory&gt;();

<span class="pl-k">class</span> <span class="pl-en">MyCustomFactory</span> : <span class="pl-k">IFactory</span>&lt;<span class="pl-k">IFoo</span>&gt;
{
    Bar _bar;

    <span class="pl-k">public</span> <span class="pl-en">MyCustomFactory</span>(<span class="pl-k">Bar</span> <span class="pl-smi">bar</span>)
    {
        _bar = bar;
    }

    <span class="pl-k">public</span> IFoo <span class="pl-en">Create</span>()
    {
        ...
    }
}</pre></div>

<p>The <code>ToSingleFactory</code> binding can be useful when you want 
to define a singleton, but it has complex construction logic that you 
want to define yourself.  You could use <code>ToSingleMethod</code>, but this can get ugly if your construction logic itself has its own dependencies that it needs.  Using <code>ToSingleFactory</code>
 for this case it is nice because any dependencies that you require for 
construction can be simply added to the factory constructor</p>

<p>19 - <strong>Untyped Bindings</strong></p>

<div class="highlight highlight-source-cs"><pre>Container.Bind(<span class="pl-k">typeof</span>(IFoo)).ToSingle(<span class="pl-k">typeof</span>(Foo));</pre></div>

<p>In some cases it is not possible to use the generic versions of the 
Bind&lt;&gt; functions.  In these cases a non-generic version is 
provided, which works by taking in a Type value as a parameter.</p>

<p>20 - <strong>BindIFactory</strong> - Bind type <code>IFactory&lt;&gt;</code> to a construction method</p>

<div class="highlight highlight-source-cs"><pre>Container.BindIFactory&lt;IFoo&gt;().ToFactory&lt;Foo&gt;();</pre></div>

<p>This bind method is used to create abstract factories.</p>

<p>The above line results in all dependencies of type <code>IFactory&lt;IFoo&gt;</code> being bound to an object that returns type <code>Foo</code> when its Create() method is called.</p>

<p>See the <a href="#abstract-factories">abstract factories section</a> for more information on abstract factories.</p>

<p>21 - <strong>BindFacadeFactory</strong> - Declare a nested container facade factory.</p>

<p>See <a href="#sub-containers-and-facades">this section</a> for more details on this binding.</p>

<p>22 - <strong>BindFacade</strong> - Declare a nested container facade.</p>

<p>See <a href="#sub-containers-and-facades">this section</a> for more details on this binding.</p>

<h2>
<a id="user-content-list-bindings" class="anchor" href="#list-bindings" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-list-bindings"></a>List Bindings</h2>

<p>When Zenject finds multiple bindings for the same type, it interprets
 that to be a list.  So, in the example code below, Bar would get a list
 containing a new instance of Foo1, Foo2, and Foo3:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// In an installer somewhere</span>
Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo1&gt;();
Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo2&gt;();
Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo3&gt;();

...

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Bar</span>
{
    <span class="pl-k">public</span> <span class="pl-en">Bar</span>(List&lt;IFoo&gt; foos)
    {
    }
}</pre></div>

<p>Also worth noting is that if you try and declare a single dependency 
of IFoo (like Bar below) and there are multiple bindings for it, then 
Zenject will throw an exception, since Zenject doesn't know which 
instance of IFoo to use.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Bar</span>
{
    <span class="pl-k">public</span> <span class="pl-en">Bar</span>(<span class="pl-k">IFoo</span> <span class="pl-smi">foo</span>)
    {
    }
}</pre></div>

<p>Also, if the empty list is valid, then you should mark your List constructor parameter (or [Inject] field) as optional (see <a href="#optional-binding">here</a> for details).</p>

<h2>
<a id="user-content-optional-binding" class="anchor" href="#optional-binding" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-optional-binding"></a>Optional Binding</h2>

<p>You can declare some dependencies as optional as follows:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Bar</span>
{
    <span class="pl-k">public</span> <span class="pl-en">Bar</span>(
        [InjectOptional]
        <span class="pl-k">IFoo</span> <span class="pl-smi">foo</span>)
    {
        ...
    }
}
...

<span class="pl-c">// Can leave this commented or not and it will still work</span>
<span class="pl-c">// Container.Bind&lt;IFoo&gt;().ToSingle();</span></pre></div>

<p>In this case, if IFoo is not bound in any installers, then it will be passed as null.</p>

<p>Note that when declaring dependencies with primitive types as 
optional, they will be given their default value (eg. 0 for ints).  You 
may also assign an explicit default using the standard C# way such as:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Bar</span>
{
    <span class="pl-k">public</span> <span class="pl-en">Bar</span>(<span class="pl-k">int</span> <span class="pl-smi">foo</span> <span class="pl-k">=</span> <span class="pl-c1">5</span>)
    {
        ...
    }
}
...

<span class="pl-c">// Can leave this commented or not and it will still work</span>
<span class="pl-c">// Container.Bind&lt;int&gt;().ToInstance(1);</span></pre></div>

<p>Note also that the [InjectOptional] is not necessary in this case, since it's already implied by the default value.</p>

<p>Alternatively, you can define the primitive parameter as nullable, 
and perform logic depending on whether it is supplied or not, such as:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Bar</span>
{
    <span class="pl-k">int</span> _foo;

    <span class="pl-k">public</span> <span class="pl-en">Bar</span>(
        [InjectOptional]
        int? foo)
    {
        <span class="pl-k">if</span> (foo == <span class="pl-c1">null</span>)
        {
            <span class="pl-c">// Use 5 if unspecified</span>
            _foo = <span class="pl-c1">5</span>;
        }
        <span class="pl-k">else</span>
        {
            _foo = foo.Value;
        }
    }
}

...

<span class="pl-c">// Can leave this commented or not and it will still work</span>
<span class="pl-c">// Container.Bind&lt;int&gt;().ToInstance(1);</span></pre></div>

<h2>
<a id="user-content-identifiers" class="anchor" href="#identifiers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-identifiers"></a>Identifiers</h2>

<p>You can also give a name to your binding by supplying it as a parameter to the Bind() method.  For example:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFoo&gt;(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>).ToSingle&lt;Foo1&gt;();
Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo2&gt;();

...

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Bar1</span>
{
    [Inject(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)]
    IFoo _foo;
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Bar2</span>
{
    [Inject]
    IFoo _foo;
}</pre></div>

<p>In this example, the Bar1 class will be given an instance of Foo1, 
and the Bar2 class will use the default version of IFoo which is bound 
to Foo2.</p>

<p>Note also that you can add a name to constructor arguments as well, for example:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Bar</span>
{
    Foo _foo;

    <span class="pl-k">public</span> <span class="pl-en">Bar</span>(
        [Inject(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)] Foo foo)
    {
    }
}</pre></div>

<p>You can also do the same with [PostInject] parameters:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Bar</span>
{
    Foo _foo;

    <span class="pl-k">public</span> <span class="pl-en">Bar</span>()
    {
    }

    [PostInject]
    <span class="pl-k">public</span> <span class="pl-en">Init</span>(
        [Inject(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)] Foo foo)
    {
    }
}</pre></div>

<p>It is also possible to supply an identifier to the ToSingle methods 
as well.  This allows you to force Zenject to create multiple singletons
 instead of just one.  Normally, the singleton is uniquely identified 
based on the type given as generic argument to the ToSingle&lt;&gt; 
method.  So for example:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo&gt;();
Container.Bind&lt;IBar&gt;().ToSingle&lt;Foo&gt;();
Container.Bind&lt;IQux&gt;().ToSingle&lt;Qux&gt;();</pre></div>

<p>In the above code, both uses of <code>ToSingle&lt;Foo&gt;()</code> will be bound to the same instance.  Only one instance of Foo will be created.</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo&gt;(<span class="pl-s"><span class="pl-pds">"</span>foo1<span class="pl-pds">"</span></span>);
Container.Bind&lt;IBar&gt;().ToSingle&lt;Foo&gt;(<span class="pl-s"><span class="pl-pds">"</span>foo2<span class="pl-pds">"</span></span>);</pre></div>

<p>In this case, two instances will be created.</p>

<p>Something else worth noting is that the behaviour of ToSinglePrefab works similarly.  Given the following:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFoo&gt;().ToSinglePrefab&lt;Foo&gt;(MyPrefab);
Container.Bind&lt;IBar&gt;().ToSinglePrefab&lt;Bar&gt;(MyPrefab);</pre></div>

<p>It will only instantiate the prefab MyPrefab once.  The generic 
parameter given to ToSinglePrefab can be interpreted as "Search the 
instantiated prefab for this component".  If instead, you want Zenject 
to instantiate a new instance of the prefab for each ToSinglePrefab 
binding, then you can do that as well by supplying an identifier to the 
ToSinglePrefab function like so:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFoo&gt;().ToSinglePrefab&lt;Foo&gt;(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, MyPrefab);
Container.Bind&lt;IBar&gt;().ToSinglePrefab&lt;Bar&gt;(<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>, MyPrefab);</pre></div>

<p>Now two instances of the prefab will be created.</p>

<h2>
<a id="user-content-conditional-bindings" class="anchor" href="#conditional-bindings" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-conditional-bindings"></a>Conditional Bindings</h2>

<p>In many cases you will want to restrict where a given dependency is injected.  You can do this using the following syntax:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo1&gt;().WhenInjectedInto&lt;Bar1&gt;();
Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo2&gt;().WhenInjectedInto&lt;Bar2&gt;();</pre></div>

<p>Note that <code>WhenInjectedInto</code> is simple shorthand for the following.  You can use the more general <code>When()</code> method for more complex conditionals.  For example, this is equivalent to WhenInjectedInto:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo&gt;().When(context =&gt; context.ObjectType == <span class="pl-k">typeof</span>(Bar));</pre></div>

<p>The InjectContext class (which is passed as the <code>context</code> parameter above) contains the following information that you can use in your conditional:</p>

<ul>
<li>
<code>Type ObjectType</code> - The type of the newly instantiated 
object, which we are injecting dependencies into.  Note that this is 
null for root calls to Resolve&lt;&gt; or Instantiate&lt;&gt;</li>
<li>
<code>object ObjectInstance</code> - The newly instantiated instance 
that is having its dependencies filled.  Note that this is only 
available when injecting fields or into [PostInject] and null for 
constructor parameters</li>
<li>
<code>string Identifier</code> - This will be null in most cases and set to whatever is given as a parameter to the [Inject] attribute.  For example, <code>[Inject("foo")] _foo</code> will result in <code>Identifier</code> being equal to the string "foo".</li>
<li>
<code>string ConcreteIdentifier</code> - This will be null in most cases
 and set to whatever is given as the string identifier to the 
ToSingle&lt;&gt; (or similar) methods.</li>
<li>
<code>string MemberName</code> - The name of the field or parameter that
 we are injecting into.  This can be used, for example, in the case 
where you have multiple constructor parameters that are strings.  
However, using the parameter or field name can be error prone since 
other programmers may refactor it to use a different name.  In many 
cases it's better to use an explicit identifier</li>
<li>
<code>Type MemberType</code> - The type of the field or parameter that we are injecting into.</li>
<li>
<code>InjectContext ParentContext</code> - This contains information on 
the entire object graph that precedes the current class being created.  
For example, dependency A might be created, which requires an instance 
of B, which requires an instance of C.  You could use this field to 
inject different values into C, based on some condition about A.  This 
can be used to create very complex conditions using any combination of 
parent context information.  Note also that ParentContext.MemberType is 
not necessarily the same as ObjectType, since the ObjectType could be a 
derived type from ParentContext.MemberType</li>
<li>
<code>bool Optional</code> - True if the [InjectOptional] parameter is declared on the field being injected</li>
</ul>

<h2>
<a id="user-content-itickable" class="anchor" href="#itickable" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-itickable"></a>ITickable</h2>

<p>I personally prefer to avoid the extra weight of MonoBehaviours when 
possible in favour of just normal C# classes.  Zenject allows you to do 
this much more easily by providing interfaces that mirror functionality 
that you would normally need to use a MonoBehaviour for.</p>

<p>For example, if you have code that needs to run per frame, then you can implement the ITickable interface:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Ship</span> : <span class="pl-k">ITickable</span>
{
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Tick</span>()
    {
        <span class="pl-c">// Perform per frame tasks</span>
    }
}</pre></div>

<p>Then it's just a matter of including the following in one of your installers:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;ITickable&gt;().ToSingle&lt;Ship&gt;();</pre></div>

<p>Note that the order that Tick() is called on all ITickables is also configurable, as outlined <a href="#update--initialization-order">here</a>.</p>

<h2>
<a id="user-content-iinitializable-and-postinject" class="anchor" href="#iinitializable-and-postinject" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-iinitializable-and-postinject"></a>IInitializable and PostInject</h2>

<p>If you have some initialization that needs to occur on a given 
object, you can include this code in the constructor.  However, this 
means that the initialization logic would occur in the middle of the 
object graph being constructed, so it may not be ideal.</p>

<p>One alternative is to implement IInitializable, and then perform 
initialization logic in an Initialize() method.  This method would be 
called immediately after the entire object graph is constructed.  This 
is also nice because the initialization order is customizable in a 
similar way to ITickable, as explained <a href="#update--initialization-order">here</a>.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Ship</span> : <span class="pl-k">IInitializable</span>
{
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Initialize</span>()
    {
        <span class="pl-c">// Initialize your object here</span>
    }
}</pre></div>

<p>IInitializable works well for start-up initialization, but what about
 for objects that are created dynamically via factories?  (see <a href="#creating-objects-dynamically">this section</a> for what I'm referring to here).  For these cases you will most likely want to use a [PostInject] method:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>
{
    [Inject]
    IBar _bar;

    [PostInject]
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Initialize</span>()
    {
        ...
        _bar.DoStuff();
        ...
    }
}</pre></div>

<h2>
<a id="user-content-implementing-idisposable" class="anchor" href="#implementing-idisposable" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-implementing-idisposable"></a>Implementing IDisposable</h2>

<p>If you have external resources that you want to clean up when the app
 closes, the scene changes, or for whatever reason the composition root 
object is destroyed, you can do the following:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Logger</span> : <span class="pl-k">IInitializable</span>, <span class="pl-k">IDisposable</span>
{
    FileStream _outStream;

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Initialize</span>()
    {
        _outStream = File.Open(<span class="pl-s"><span class="pl-pds">"</span>log.txt<span class="pl-pds">"</span></span>, FileMode.Open);
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Log</span>(<span class="pl-k">string</span> <span class="pl-smi">msg</span>)
    {
        _outStream.WriteLine(msg);
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Dispose</span>()
    {
        _outStream.Close();
    }
}</pre></div>

<p>Then in your installer you can include:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;Logger&gt;().ToSingle();
Container.Bind&lt;IInitializable&gt;().ToSingle&lt;Logger&gt;();
Container.Bind&lt;IDisposable&gt;().ToSingle&lt;Logger&gt;();</pre></div>

<p>Or you can use the following shortcut:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;Logger&gt;().ToSingle();
Container.BindAllInterfacesToSingle&lt;Logger&gt;();</pre></div>

<p>This works because when the scene changes or your unity application 
is closed, the unity event OnDestroy() is called on all MonoBehaviours, 
including the CompositionRoot class, which then triggers all objects 
that are bound to IDisposable</p>

<p>Note that this example may or may not be a good idea (for example, 
the file will be left open if your app crashes), but illustrates the 
point  :)</p>

<h2>
<a id="user-content-installers" class="anchor" href="#installers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-installers"></a>Installers</h2>

<p>Often, there is some collections of related bindings for each 
sub-system and so it makes sense to group those bindings into a 
re-usable object.  In Zenject this re-usable object is called an 
Installer.  You can define a new installer as follows:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">FooInstaller</span> : <span class="pl-k">MonoInstaller</span>
{
    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">InstallBindings</span>()
    {
        Container.Bind&lt;ITickable&gt;().ToSingle&lt;Foo&gt;();
        Container.Bind&lt;IInitializable&gt;().ToSingle&lt;Foo&gt;();
    }
}</pre></div>

<p>You add bindings by overriding the InstallBindings method, which is 
called by the CompositionRoot when your scene starts up.  MonoInstaller 
is a MonoBehaviour so you can add FooInstaller by attaching it to a 
GameObject.  Since it is a GameObject you can also add public members to
 it to configure your installer from the Unity inspector, to add 
references within the scene, references to assets, or simply tuning 
data.</p>

<p>Note that in order for your installer to be triggered it must be 
attached to the Installers property of the CompositionRoot object.  This
 is necessary to be able to control the order that installers are called
 in (which you can do by dragging rows around in the Installers 
property).  The order should not usually matter (since nothing is 
instantiated during the install process) however it can matter in some 
cases, such as when you configure an Installer from an existing 
installer (eg: <code>Container.BindInstance("mysetting").WhenInjectedInto&lt;MyOtherInstaller&gt;()</code>).</p>

<p>In many cases you want to have your installer derive from 
MonoInstaller, so that you can have inspector settings.  There is also 
another base class called simply <code>Installer</code> which you can use in cases where you do not need it to be a MonoBehaviour.</p>

<p>You can also call installers from an existing installer.  For example:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">BarInstaller</span> : <span class="pl-k">Installer</span>
{
    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">InstallBindings</span>()
    {
        ...
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">FooInstaller</span> : <span class="pl-k">MonoInstaller</span>
{
    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">InstallBindings</span>()
    {
        Container.Install&lt;BarInstaller&gt;();
    }
}</pre></div>

<p>Note that in this case BarInstaller is of type Installer and not MonoInstaller, which is why we can simply call <code>Container.Install&lt;BarInstaller&gt;</code>.
  By using Installer for BarInstaller instead of MonoInstaller, we don't
 need an instance of BarInstaller in our scene to use it.  Any calls to 
Container.Install will immediately instantiate the given installer type 
and then call InstallBindings on it.  This will repeat for any 
installers that this installer installs.</p>

<p>One of the main reasons we use installers as opposed to just having 
all our bindings declared all at once for each scene, is to make them 
re-usable.  This is not a problem for installers of type <code>Installer</code> because you can simply call <code>Container.Install</code> as described above for every scene you wish to use it in, but then how would we re-use a MonoInstaller in multiple scenes?</p>

<p>There are two ways to do this.</p>

<ol>
<li><p>Prefabs.  After attaching your MonoInstaller to a gameobject in 
your scene, you can then create a prefab out of it.  This is nice 
because it allows you to share any configuration that you've done in the
 inspector on the MonoInstaller across scenes (and also have per-scene 
overrides if you want).</p></li>
<li><p><code>Container.Install&lt;&gt;</code>.  You can also call 
Container.Install just as we did with BarInstaller above for 
MonoInstallers.  However, unlike with installers of type <code>Installer</code>,
 Zenject cannot simply create a new instance and then install that, 
because the MonoInstaller could have inspector settings on it.  To 
address this, when Container.Install is called with a MonoInstaller, 
Zenject will follow a naming convention to find the prefab for the 
MonoInstaller.  For example:</p></li>
</ol>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Note that this is a MonoInstaller and has inspector settings</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">QuxInstaller</span> : <span class="pl-k">MonoInstaller</span>
{
    <span class="pl-k">public</span> <span class="pl-k">string</span> MyConfigurationSetting;

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">InstallBindings</span>()
    {
        ...
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">FooInstaller</span> : <span class="pl-k">MonoInstaller</span>
{
    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">InstallBindings</span>()
    {
        <span class="pl-c">// When this is called, Zenject will look for a prefab at Resources/Installers/QuxInstaller.prefab and load that</span>
        Container.Install&lt;QuxInstaller&gt;();
    }
}</pre></div>

<p>As mentioned in the above code, Zenject will search for a prefab 
named QuxInstaller.prefab in all the Resources/Installer directories in 
your project.  This is sometimes a useful alternative to adding 
installer prefabs to every scene because it allows you to keep the 
objects in your scenes extremely light.</p>

<h2>
<a id="user-content-zenject-order-of-operations" class="anchor" href="#zenject-order-of-operations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-zenject-order-of-operations"></a>Zenject Order Of Operations</h2>

<p>A Zenject driven application is executed by the following steps:</p>

<ol>
<li>Unity Awake() phase begins</li>
<li>CompositionRoot.Awake() method is called.  NOTE: This should always 
be the first thing executed in your scene.  By default this should work 
this way out of the box, because the executionOrder property is set to 
-9999 for the CompositionRoot classes.  You can also verify that this is
 the case by selecting <code>Edit -&gt; Project Settings -&gt; Script Execution Order</code>
 and making sure that GlobalCompositionRoot and SceneCompositionRoot are
 at the top.  (GlobalCompositionRoot goes first because global bindings 
should alway get updated before scene bindings)</li>
<li>Composition Root creates a new DiContainer object to be used to contain all instances used in the scene</li>
<li>Composition Root iterates through all the Installers that have been 
added to it via the Unity Inspector, and updates them to point to the 
new DiContainer.  It then calls InstallBindings() on each installer.</li>
<li>Each Installer then registers different sets of dependencies 
directly on to the given DiContainer by calling one of the Bind&lt;&gt; 
methods.  Note that the order that this binding occurs should not 
generally matter. Each installer may also include other installers by 
calling Container.Install&lt;&gt;. Each installer can also add bindings 
to configure other installers, however note that in this case order 
might actually matter, since you will have to make sure that code 
configuring other installers is executed before the installers that you 
are configuring! You can control the order by simply re-ordering the 
Installers property of the CompositionRoot</li>
<li>The Composition Root then injects all MonoBehaviours that are in the
 scene with their dependencies. Note that since MonoBehaviours are 
instantiated by Unity we cannot use constructor injection in this case 
and therefore [PostInject] injection, field injection or property 
injection must be used instead.</li>
<li>After filling in the scene dependencies the Composition Root then 
executes a single resolve for 'IFacade'.  This class represents the root
 of the object graph.  The Facade class by default has dependencies on 
TickableManager, InitializableManager, and DisposableManager classes, 
and therefore Zenject constructs instances of those as well before 
creating the main dependency root.  Those classes contains dependencies 
for lists of ITickable, IInitializable, and IDisposables.  So once again
 Zenject resolves all instances bound to any of these interfaces before 
constructing the manager classes.  This is important to know because it 
is why when you bind something to ITickable/IInitializable/IDisposable, 
it is always created at startup.</li>
<li>If any required dependencies cannot be resolved, a ZenjectResolveException is thrown</li>
<li>All other MonoBehaviour's in your scene has their Awake() method called</li>
<li>Unity Start() phase begins</li>
<li>CompositionRoot.Start() method is called.  This will trigger the 
Initialize() method on all IInitializable objects in the order specified
 in the installers.  The execution order mentioned above should 
guarantee that IInitializable.Initialize() occurs before any Start() 
method in your scene</li>
<li>All other MonoBehaviour's in your scene has their Start() method called</li>
<li>Unity Update() phase begins</li>
<li>Facade.Update() is called, which results in Tick() being called for 
all ITickable objects (in the order specified in the installers)</li>
<li>All other MonoBehaviour's in your scene has their Update() method called</li>
<li>Steps 13 - 15 is repeated for LateUpdate</li>
<li>At the same time, Steps 13 - 15 is repeated for FixedUpdate according to the physics timestep</li>
<li>App is exited</li>
<li>Dispose() is called on all objects mapped to IDisposable (see <a href="#implementing-idisposable">here</a> for details)</li>
</ol>

<h2>
<a id="user-content-di-guidelines--recommendations--gotchas--tips-and-tricks" class="anchor" href="#di-guidelines--recommendations--gotchas--tips-and-tricks" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-di-guidelines--recommendations"></a>DI Guidelines / Recommendations / Gotchas / Tips and Tricks</h2>

<ul>
<li>
<p><strong>Do not use GameObject.Instantiate if you want your objects to have their dependencies injected</strong></p>

<ul>
<li>If you want to create a prefab yourself, you can use either 
IInstantiator interface (which is automatically included in every 
container) or the DiContainer directly, which will automatically fill in
 any fields that are marked with the [Inject] attribute.  The 
IInstantiator interface and DiContainer contain various methods to 
create from prefabs or create from empty game objects, etc.<br>
<strong>In other words:  If you want your dynamically created game 
object to have its fields injected, do not use GameObject.Instantiate 
and use DiContainer.InstantiatePrefab or GameObjectFactory instead</strong>
</li>
<li>For more information on GameObjectFactory see <a href="#game-object-factories">this section</a>
</li>
</ul>
</li>
<li>
<p><strong>The container should <em>only</em> be referenced in the composition root "layer"</strong></p>

<ul>
<li>Note that factories are part of this layer and the container can be 
referenced there (which is necessary to create objects at runtime).  For
 example, see ShipStateFactory in the sample project.  See <a href="#creating-objects-dynamically">here</a> for more details on this.</li>
</ul>
</li>
<li>
<p><strong>Do not use IInitializable, ITickable and IDisposable for dynamically created objects</strong></p>

<ul>
<li>Objects that are of type IInitializable are only initialized once, 
at startup.  If you create an object through a factory, and it derives 
from IInitializable, the Initialize() method will not be called.  You 
should use [PostInject] in this case.</li>
<li>The same applies to ITickable and IDisposable.  Deriving from these 
will do nothing unless they are part of the original object graph 
created at startup.</li>
<li>If you have dynamically created objects that have an Update() 
method, it is usually best to call Update() on those manually, and often
 there is a higher level manager-like class in which it makes sense to 
do this from.  If however you prefer to use ITickable for dynamically 
objects you can declare a dependency to TickableManager and add/remove 
it explicitly as well.</li>
</ul>
</li>
<li>
<p><strong>Using multiple constructors</strong></p>

<ul>
<li>Zenject does not support injecting into multiple constructors 
currently.  You can have multiple constructors however you must mark one
 of them with the [Inject] attribute so Zenject knows which one to use.</li>
</ul>
</li>
<li>
<p><strong>Injecting into MonoBehaviours</strong></p>

<ul>
<li>One issue that often arises when using Zenject is that a game object
 is instantiated dynamically, and then one of the monobehaviours on that
 game object attempts to use one of its injected field dependencies in 
its Start() or Awake() methods.  Often in these cases the dependency 
will still be null, as if it was never injected.  The issue here is that
 Zenject cannot fill in the dependencies until after the call to 
GameObject.Instantiate completes, and in most cases 
GameObject.Instantiate will call the Start() and Awake() methods.  The 
solution is to use neither Start() or Awake() and instead define a new 
method and mark it with a [PostInject] attribute.  This will guarantee 
that all dependencies have been resolved before executing the method.</li>
</ul>
</li>
<li>
<p><strong>Using Zenject outside of Unity</strong></p>

<ul>
<li>Zenject is primarily designed to work within Unity3D.  However, it 
can also be used as a general purpose DI framework outside of Unity3D.  
In order to do this, you just have to build Zenject with the define 
ZEN_NOT_UNITY3D enabled.  Note also that if multi-threading support is 
needed (for eg. if used with ASP.NET MVC) then you will also have to 
define ZEN_MULTITHREADING</li>
</ul>
</li>
<li>
<p><strong>Lazily instantiated objects and the object graph</strong></p>

<ul>
<li>Zenject will only instantiate any objects that are referenced in the
 object graph that is generated based on the bindings that you've 
invoked in your installer.  Internally, how it works is that Zenject has
 one single class that represents the root of the entire object graph 
(aka IDependencyRoot).  For unity projects this is typically the 
'UnityDependencyRoot' class.  This class has a dependency on all 
ITickable, IInitializable, and IDisposable objects.  This is important 
to understand because it means that any class that you bind to 
ITickable, IInitializable, or IDisposable will always be created as part
 of the initial object graph of your application.  And only otherwise 
will your class be lazily instantiated when referenced by another class.</li>
</ul>
</li>
<li>
<p><strong>The order that things occur in is wrong, like injection is 
occurring too late, or Initialize() event is not called at the right 
time, etc.</strong></p>

<ul>
<li>It may be because the execution order of the Zenject classes 
'SceneCompositionRoot' and 'GlobalCompositionRoot' may be incorrect.  
These classes should always have the earliest or near earliest execution
 order.  This should already be set by default (since this settings is 
in the SceneCompositionRoot.cs.meta and GlobalCompositionRoot.cs.meta 
files). However, if you are compiling Zenject yourself or have a unique 
configuration you may want to make sure, which you can do by going to 
"Edit -&gt; Project Settings -&gt; Script Execution Order" and 
confirming that GlobalCompositionRoot and SceneCompositionRoot are at 
the top, before the default time.</li>
</ul>
</li>
</ul>

<p>Please feel free to submit any other sources of confusion to <a href="mailto:sfvermeulen@gmail.com">sfvermeulen@gmail.com</a> and I will add it here.</p>

<h2>
<a id="user-content-global-bindings" class="anchor" href="#global-bindings" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-global-bindings"></a>Global Bindings</h2>

<p>This all works great for each individual scene, but what if you have 
dependencies that you wish to persist permanently across all scenes?  In
 Zenject you can do this by adding installers to a global container.</p>

<p>To do this, first add a global installers asset to your project 
directory then add installers to it.  Create or find a folder named 
Resources in your project tab, then right click and select Create -&gt; 
Zenject -&gt; Global Installers Asset.  You should then see a new asset 
in the selected Resources folder called 'ZenjectGlobalInstallers'.</p>

<p>If you click on this it will display a property for the list of 
Installers in the same way that it does for the composition root object 
that is placed in each scene.  The only difference is that the 
installers you add here must exist in the project as prefabs and cannot 
exist in any specific scene.  You can then directly reference those 
prefabs by dragging them into the Installers property of the global 
installers asset.</p>

<p>Note that you can add multiple Global Installers asset's in different resource folders and they will all be installed.</p>

<p>When you start any scene that contains a Scene Composition Root, this
 will cause every Global Installers Asset in your project to be 
installed.  This will always occur before any scene specific installers 
are called.  Note also that this only occurs once.  If you load another 
scene from the first scene, your global installers will not be called 
again and the bindings that it added previously will persist into the 
new scene.  You can declare ITickable / IInitializable / IDisposable 
objects in your global installers in the same way you do for your scene 
installers with the result being IInitializable.Initialize is called 
only once across each play session and IDisposable.Dispose is only 
called once the application is fully stopped.</p>

<p>This works because the container defined for each scene is nested 
inside the global container that your global installers bind into.  For 
more information on nested containers see <a href="#sub-containers-and-facades">here</a>.</p>

<h2>
<a id="user-content-update--initialization-order" class="anchor" href="#update--initialization-order" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-update--initialization-order"></a>Update / Initialization Order</h2>

<p>In many cases, especially for small projects, the order that classes 
update or initialize in does not matter.  However, in larger projects 
update or initialization order can become an issue.  This can especially
 be an issue in Unity, since it is often difficult to predict in what 
order the Start(), Awake(), or Update() methods will be called in.  
Unfortunately, Unity does not have an easy way to control this (besides 
in Edit -&gt; Project Settings -&gt; Script Execution Order, though that
 is pretty awkward to use)</p>

<p>In Zenject, by default, ITickables and IInitializables are updated in
 the order that they are added, however for cases where the update or 
initialization order matters, there is a much better way:  By specifying
 their priorities explicitly in the installer.  For example, in the 
sample project you can find this code in the scene installer:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">AsteroidsInstaller</span> : <span class="pl-k">MonoInstaller</span>
{
    ...

    <span class="pl-c">// We don't need to include these bindings but often its nice to have</span>
    <span class="pl-c">// control over initialization-order and update-order</span>
    <span class="pl-k">void</span> <span class="pl-en">InitExecutionOrder</span>()
    {
        Container.Install&lt;ExecutionOrderInstaller&gt;(
            <span class="pl-k">new</span> List&lt;Type&gt;()
            {
                <span class="pl-c">// Re-arrange this list to control update order</span>
                <span class="pl-c">// These classes will be initialized and updated in this order and disposed of in reverse order</span>
                <span class="pl-k">typeof</span>(AsteroidManager),
                <span class="pl-k">typeof</span>(GameController),
            });
    }

    ...

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">InstallBindings</span>()
    {
        ...
        InitExecutionOrder();
        ...
    }

}</pre></div>

<p>This way, you won't hit a wall at the end of the project due to some unforeseen order-dependency.</p>

<p>You can also assign priorities one class at a time using the following helper method:</p>

<div class="highlight highlight-source-cs"><pre>ExecutionOrderInstaller.BindPriority&lt;Foo&gt;(Container, -<span class="pl-c1">100</span>);
Container.Bind&lt;IInitializable&gt;().ToSingle&lt;Foo&gt;();
Container.Bind&lt;ITickable&gt;().ToSingle&lt;Foo&gt;();
Container.Bind&lt;IInitializable&gt;().ToSingle&lt;Bar&gt;();</pre></div>

<p>Note that any ITickables, IInitializables, or IDisposable's that are 
not assigned a priority are automatically given the priority of zero.  
This allows you to have classes with explicit priorities executed either
 before or after the unspecified classes.  For example, the above code 
would result in 'Foo.Initialize' being called before 'Bar.Initialize'.  
If you instead gave it 100 instead of -100, it would be executed 
afterwards.</p>

<p>Note also that classes are disposed of in the opposite order.  This 
is similar to how Unity handles explicit script execution order.</p>

<h2>
<a id="user-content-object-graph-validation" class="anchor" href="#object-graph-validation" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-object-graph-validation"></a>Object Graph Validation</h2>

<p>The usual workflow when setting up bindings using a DI framework is something like this:</p>

<ul>
<li>Add some number of bindings in code</li>
<li>Execute your app</li>
<li>Observe a bunch of DI related exceptions</li>
<li>Modify your bindings to address problem</li>
<li>Repeat</li>
</ul>

<p>This works ok for small projects, but as the complexity of your 
project grows it is often a tedious process.  The problem gets worse if 
the startup time of your application is particularly bad, or when the 
resolve errors only occur from factories at various points at runtime.  
What would be great is some tool to analyze your object graph and tell 
you exactly where all the missing bindings are, without requiring the 
cost of firing up your whole app.</p>

<p>You can do this in Zenject out-of-the-box by executing the menu item <code>Edit -&gt; Zenject -&gt; Validate Current Scene</code>
 or simply hitting CTRL+SHIFT+V with the scene open that you want to 
validate.  This will execute all installers for the current scene and 
construct a fully bound container (with null values for all instances). 
  It will then iterate through the object graphs and verify that all 
bindings can be found (without actually instantiating any of them).</p>

<p>Note that if you want to use this feature (which I recommend as its 
very useful) then you should avoid instantiating new objects in your 
installers and executing other code that has similar side effects.</p>

<p>Also, if you happen to be a fan of automated testing (as I am) then 
you can include calls to this menu item in unity batch mode as part of 
your testing suite.  For example, to validate the scenes in the sample 
project from the command line, you can just execute this:</p>

<pre><code>"[PATH TO UNITY]" -projectPath "[PATH TO SAMPLE PROJECT]" -executeMethod Zenject.ZenEditorUtil.ValidateScenesFromScript -batchmode -nographics "-CustomArg:scenes=Asteroids,AsteroidsDecoratorExample"
</code></pre>

<p>This will return an error code if validation fails.  If it succeeded,
 it will return 0 and the log for the unity editor will contain the line
 "Successfully validated all 2 scenes".</p>

<h2>
<a id="user-content-using-the-unity-inspector-to-configure-settings" class="anchor" href="#using-the-unity-inspector-to-configure-settings" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-using-the-unity-inspector-to-configure-settings"></a>Using the Unity Inspector To Configure Settings</h2>

<p>One implication of writing most of your code as normal C# classes 
instead of MonoBehaviour's is that you lose the ability to configure 
data on them using the inspector.  You can however still take advantage 
of this in Zenject by using the following pattern, as seen in the sample
 project:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">AsteroidsInstaller</span> : <span class="pl-k">MonoInstaller</span>
{
    <span class="pl-k">public</span> Settings SceneSettings;

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">InstallBindings</span>()
    {
        ...
        Container.BindInstance(SceneSettings.StateMoving);
        ...
    }

    [Serializable]
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Settings</span>
    {
        ...
        <span class="pl-k">public</span> ShipStateMoving.Settings StateMoving;
        ...
    }
}</pre></div>

<p>Note that if you follow this method, you will have to make sure to 
always include the [Serializable] attribute on your settings wrappers, 
otherwise they won't show up in the Unity inspector.</p>

<p>To see this in action, start the asteroids scene and try adjusting <code>Ship -&gt; State Moving -&gt; Move Speed</code> setting and watch live as your ship changes speed.</p>

<h2>
<a id="user-content-creating-objects-dynamically" class="anchor" href="#creating-objects-dynamically" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-creating-objects-dynamically"></a>Creating Objects Dynamically</h2>

<p>One of the things that often confuses people new to dependency 
injection is the question of how to create new objects dynamically, 
after the app/game has fully started up and all the IInitializable 
objects have had their Initialize() method called.  For example, if you 
are writing a game in which you are spawning new enemies throughout the 
game, then you will want to construct a new object graph for the 'enemy'
 class.  How to do this?  The answer: Factories.</p>

<p>Remember that an important part of dependency injection is to reserve
 use of the container to strictly the "Composition Root Layer".  The 
container class (DiContainer) is included as a dependency in itself 
automatically so there is nothing stopping you from ignoring this rule 
and injecting the container into any classes that you want.  For 
example, the following code will work:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Enemy</span>
{
    DiContainer Container;

    <span class="pl-k">public</span> <span class="pl-en">Enemy</span>(<span class="pl-k">DiContainer</span> <span class="pl-smi">container</span>)
    {
        Container = container;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Update</span>()
    {
        ...
        <span class="pl-k">var</span> player = Container.Resolve&lt;Player&gt;();
        WalkTowards(player.Position);
        ...
        etc.
    }
}</pre></div>

<p>HOWEVER, the above code is an example of an anti-pattern.  This will 
work, and you can use the container to get access to all other classes 
in your app, however if you do this you will not really be taking 
advantage of the power of dependency injection.  This is known, by the 
way, as <a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/">Service Locator Pattern</a>.</p>

<p>Of course, the dependency injection way of doing this would be the following:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Enemy</span>
{
    Player _player;

    <span class="pl-k">public</span> <span class="pl-en">Enemy</span>(<span class="pl-k">Player</span> <span class="pl-smi">player</span>)
    {
        _player = player;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Update</span>()
    {
        ...
        WalkTowards(_player.Position);
        ...
    }
}</pre></div>

<p>The only exception to this rule is within factories and installers.  
Again, factories and installers make up what we refer to as the 
"composition root layer".</p>

<p>For example, if you have a class responsible for spawning new enemies, before DI you might do something like this:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">EnemySpawner</span>
{
    List&lt;Enemy&gt; _enemies = <span class="pl-k">new</span> List&lt;Enemy&gt;();

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Update</span>()
    {
        <span class="pl-k">if</span> (ShouldSpawnNewEnemy())
        {
            <span class="pl-k">var</span> enemy = <span class="pl-k">new</span> Enemy();
            _enemies.Add(enemy);
        }
    }
}</pre></div>

<p>This will not work however, since in our case the Enemy class 
requires a reference to the Player class in its constructor.  We could 
add a dependency to the Player class to the EnemySpawner class, but then
 we have the problem described <a href="#theory">above</a>.  The 
EnemySpawner class doesn't care about filling in the dependencies for 
the Enemy class.  All the EnemySpawner class cares about is getting a 
new Enemy instance.</p>

<p>The recommended way to do this in Zenject is the following:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Enemy</span>
{
    Player _player;

    <span class="pl-k">public</span> <span class="pl-en">Enemy</span>(<span class="pl-k">Player</span> <span class="pl-smi">player</span>)
    {
        _player = player;
    }

    ...

    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Factory</span> : <span class="pl-k">Factory</span>&lt;<span class="pl-k">Enemy</span>&gt;
    {
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">EnemySpawner</span>
{
    Enemy.Factory _enemyFactory;
    List&lt;Enemy&gt; _enemies = <span class="pl-k">new</span> List&lt;Enemy&gt;();

    <span class="pl-k">public</span> <span class="pl-en">EnemySpawner</span>(<span class="pl-k">Enemy.Factory</span> <span class="pl-smi">enemyFactory</span>)
    {
        _enemyFactory = enemyFactory;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Update</span>()
    {
        <span class="pl-k">if</span> (ShouldSpawnNewEnemy())
        {
            <span class="pl-k">var</span> enemy = _enemyFactory.Create();
            _enemies.Add(enemy);
        }
    }
}</pre></div>

<p>Then in your installer, you would include something like:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;Enemy.Factory&gt;().ToSingle();
Container.Bind&lt;EnemySpawner&gt;().ToSingle();</pre></div>

<p>By using Enemy.Factory above, all the dependencies for the Enemy class (such as the Player) will be automatically filled in.</p>

<p>There is no requirement that the Enemy.Factory class be a nested 
class within Enemy, however we have found this to be a very useful 
convention.  Enemy.Factory is empty and simply derives from the built-in
 Zenject Factory&lt;&gt; class, which handles the work of using the 
DiContainer to construct a new instance of Enemy.</p>

<p>Also note that by using the built-in Zenject Factory&lt;&gt; class, 
the Enemy class will be automatically validated as well.  So if the 
constructor of the Enemy class includes a type that is missing a 
binding, this error can be caught before running your app, by simply 
running validation.  Validation can be especially useful for dynamically
 created objects, because otherwise you may not catch the error until 
the factory is invoked at some point during runtime.  See <a href="#object-graph-validation">this section</a> for more details on Validation.</p>

<p>However, in more complex examples, the EnemySpawner class may wish to
 pass in custom constructor arguments as well. For example, let's say we
 want to randomize the speed of each Enemy to add some interesting 
variation to our game.  Our enemy class becomes:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Enemy</span>
{
    Player _player;
    <span class="pl-k">float</span> _runSpeed;

    <span class="pl-k">public</span> <span class="pl-en">Enemy</span>(<span class="pl-k">Player</span> <span class="pl-smi">player</span>, <span class="pl-k">float</span> <span class="pl-smi">runSpeed</span>)
    {
        _player = player;
        _runSpeed = runSpeed;
    }

    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Factory</span> : <span class="pl-k">Factory</span>&lt;<span class="pl-k">float</span>, <span class="pl-k">Enemy</span>&gt;
    {
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">EnemySpawner</span>
{
    Enemy.Factory _enemyFactory;
    List&lt;Enemy&gt; _enemies = <span class="pl-k">new</span> List&lt;Enemy&gt;();

    <span class="pl-k">public</span> <span class="pl-en">EnemySpawner</span>(<span class="pl-k">Enemy.Factory</span> <span class="pl-smi">enemyFactory</span>)
    {
        _enemyFactory = enemyFactory;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Update</span>()
    {
        <span class="pl-k">if</span> (ShouldSpawnNewEnemy())
        {
            <span class="pl-k">var</span> newSpeed = Random.Range(MIN_ENEMY_SPEED, MAX_ENEMY_SPEED);
            <span class="pl-k">var</span> enemy = _enemyFactory.Create(newSpeed);
            _enemies.Add(enemy);
        }
    }
}</pre></div>

<p>The dynamic parameters that are provided to the Enemy constructor are
 declared by using generic arguments to the Factory&lt;&gt; base class 
of Enemy.Factory.  This will add a method to Enemy.Factory that takes 
the parameters with the given types.</p>

<h2>
<a id="user-content-game-object-factories" class="anchor" href="#game-object-factories" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-game-object-factories"></a>Game Object Factories</h2>

<p>You can also use the same approach as described <a href="#creating-objects-dynamically">above</a> to create factories that construct game objects.  For example:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">FooMonoBehaviour</span> : <span class="pl-k">MonoBehaviour</span>
{
    ...

    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Factory</span> : <span class="pl-k">GameObjectFactory</span>&lt;<span class="pl-k">FooMonoBehaviour</span>&gt;
    {
    }
}</pre></div>

<p>The only difference here is that this factory requires a prefab to be
 installed on it.  There is a convenience method that you can use to 
handle both installing the prefab and also declaring 
FooMonoBehaviour.Factory as a singleton:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> InstallBindings()
{
    ...

    Container.BindGameObjectFactory&lt;FooMonoBehaviour.Factory&gt;(_prefab);

    ...
}</pre></div>

<p>Now classes can simply declare a constructor parameter of type 
FooMonoBehaviour.Factory and by calling the Create() method, construct 
new instances of a given prefab.</p>

<p>Also note that there is an optional string parameter on the <code>BindGameObjectFactory</code>
 method.  This can be used to automatically group dynamically created 
objects underneath an empty transform with this name.  For example, in 
the sample game we pass "Asteroids" here since otherwise every time a 
new asteroid spawns it will clutter our scene heirarchy.</p>

<h2>
<a id="user-content-abstract-factories" class="anchor" href="#abstract-factories" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-abstract-factories"></a>Abstract Factories</h2>

<p>The above description of factories is great for most cases, however, 
there are times you do not want to depend directly on a concrete class 
and instead want your factory to return an interface instead.  This kind
 of factory is called an Abstract Factory, and it works a bit 
differently in Zenject from the standard factory as described above.</p>

<p>Let's create an example scenario, where we have multiple different implementations of a given interface:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IPathFindingStrategy</span>
{
    ...
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">AStarPathFindingStrategy</span> : <span class="pl-k">IPathFindingStrategy</span>
{
    ...
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">RandomPathFindingStrategy</span> : <span class="pl-k">IPathFindingStrategy</span>
{
    ...
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GameController</span>
{
    IFactory&lt;IPathFindingStrategy&gt; _strategyFactory;
    IPathFindingStrategy _pathFindingStrategy;

    <span class="pl-k">public</span> <span class="pl-en">GameController</span>(IFactory&lt;IPathFindingStrategy&gt; strategyFactory)
    {
        _strategyFactory = strategyFactory;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">InitPathFinding</span>()
    {
        _pathFindingStrategy = _strategyFactory.Create();

        ...
    }
}
</pre></div>

<p>For the sake of this example, let's also assume that we have to 
create the instance of IPathFindingStrategy at runtime.  Otherwise it 
would be as simple as executing <code>Container.Bind&lt;IPathFindingStrategy&gt;().ToSingle&lt;TheImplementationWeWant&gt;();</code> in one of our installers.</p>

<p>So instead, what we want to create is a dependency of type <code>IFactory&lt;IPathFindingStrategy&gt;</code> that creates an instance of the implementation that we want to use when its Create() method is called, for use in the <code>GameController</code> class above.</p>

<p>Let's say we want to use the <code>AStarPathFindingStrategy</code> implementation. The installer here looks like this:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GameInstaller</span> : <span class="pl-k">Installer</span>
{
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">InstallBindings</span>()
    {
        ...

        Container.BindIFactory&lt;IPathFindingStrategy&gt;().ToFactory&lt;AStarPathFindingStrategy&gt;();

        ...
    }
}
</pre></div>

<p>Because of the fact that there are a number of different ways to define what is returned by a given <code>IFactory&lt;&gt;</code>, it has its own bind method called <code>BindIFactory&lt;&gt;</code>.  This method takes one generic parameter that defines the generic parameter that you want to use for <code>IFactory&lt;&gt;</code>, and then provides a number of different methods that you can choose from to define what is returned by the <code>IFactory&lt;&gt;</code> that you're creating.</p>

<p>In the example installer above, our bind command maps our abstract factory <code>IFactory&lt;IPathFindingStrategy&gt;</code> to a concrete factory that returns a new instance of type <code>AStarPathFindingStrategy</code>.</p>

<p>Note that you can also pass runtime parameters by supplying extra generic arguments to the <code>BindIFactory&lt;&gt;</code> method.  For example, if our implementations of <code>IPathFindingStrategy</code> both required a constructor parameter of type <code>string</code>, our binding would look like this instead:</p>

<div class="highlight highlight-source-cs"><pre>Container.BindIFactory&lt;<span class="pl-k">string</span>, IPathFindingStrategy&gt;().ToFactory&lt;AStarPathFindingStrategy&gt;();</pre></div>

<p>This would result in a dependency of type <code>IFactory&lt;string, IPathFindingStrategy&gt;</code> with a Create() method that takes a string parameter.</p>

<p>Included below are the other methods that you can choose from when using the <code>BindIFactory&lt;&gt;</code> method:</p>

<p>1 - <strong>ToMethod([method])</strong> - Create dynamic dependency from a method</p>

<p>Results in a dependency of type <code>IFactory&lt;TContract&gt;</code> that invokes the given method.  Method must return a new instance of type <code>TContract</code>.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Examples</span>
Container.BindIFactory&lt;IFoo&gt;().ToMethod(MyMethod);

<span class="pl-c">// Using a lambda:</span>
Container.BindIFactory&lt;IFoo&gt;().ToMethod(c =&gt; <span class="pl-k">new</span> Foo());

<span class="pl-c">// With a parameter:</span>
Container.BindIFactory&lt;<span class="pl-k">string</span>, IFoo&gt;().ToMethod((text, c) =&gt; <span class="pl-k">new</span> Foo(text));</pre></div>

<p>2 - <strong>ToInstance&lt;TContract&gt;</strong> - Create dynamic dependency from an existing instance</p>

<p>Results in a dependency of type <code>IFactory&lt;TContract&gt;</code> that just returns the given instance</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Example:</span>
Container.BindIFactory&lt;IFoo&gt;().ToInstance(<span class="pl-k">new</span> Foo());</pre></div>

<p>3 - <strong>ToFactory</strong> - Create dynamic dependency for a concrete type</p>

<p>Results in a dependency of type <code>IFactory&lt;TContract&gt;</code> that will create a new instance of type <code>TContract</code>.  <code>TContract</code> must be a concrete class in this case.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Example:</span>
Container.BindIFactory&lt;Foo&gt;().ToFactory();

<span class="pl-c">// With some parameters:</span>
Container.BindIFactory&lt;<span class="pl-k">string</span>, <span class="pl-k">int</span>, <span class="pl-k">int</span>, Foo&gt;().ToFactory();</pre></div>

<p>In this example, any calls to <code>IFactory&lt;Foo&gt;.Create()</code> will return a new instance of type <code>Foo</code>.  Again, this of course requires that the generic argument to <code>BindIFactory&lt;&gt;</code> be non-abstract.</p>

<p>4 - <strong>ToFactory&lt;TConcrete&gt;</strong> - Create dynamic dependency for an abstract type</p>

<p>Results in a dependency of type <code>IFactory&lt;TContract&gt;</code> that will create a new instance of type <code>TConcrete</code>.  <code>TConcrete</code> must derive from <code>TContract</code> in this case.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Example:</span>
Container.BindIFactory&lt;IFoo&gt;().ToFactory&lt;Foo&gt;();

<span class="pl-c">// With some parameters</span>
Container.BindIFactory&lt;<span class="pl-k">string</span>, <span class="pl-k">int</span>, IFoo&gt;().ToFactory&lt;Foo&gt;();</pre></div>

<p>5 - <strong>ToIFactory&lt;TConcrete&gt;</strong> - Create dynamic dependency via lookup on another factory</p>

<p>Results in a dependency of type <code>IFactory&lt;TContract&gt;</code> that will return an instance of type <code>TConcrete</code>.  It does this by looking up <code>IFactory&lt;TConcrete&gt;</code> and calling <code>Create()</code> to create an instance of type <code>TConcrete</code>.  <code>TConcrete</code> must derive from <code>TContract</code> for this binding.  Also, it is assumed that <code>IFactory&lt;TConcrete&gt;</code> is declared in a separate binding.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// First create a simple binding for IFactory&lt;Foo&gt;</span>
Container.BindIFactory&lt;Foo&gt;().ToFactory();

<span class="pl-c">// Now create a binding for IFactory&lt;IFoo&gt; that uses the above binding</span>
Container.BindIFactory&lt;IFoo&gt;().ToIFactory&lt;Foo&gt;();</pre></div>

<p>6 - <strong>ToCustomFactory&lt;TConcrete, TFactory&gt;</strong> - Create dynamic dependency using user created factory class</p>

<p>Results in a dependency of type <code>IFactory&lt;TContract&gt;</code> that will return an instance of type <code>TConcrete</code> using the given factory of type <code>TFactory</code>.  It is assumed that <code>TFactory</code> is declared in another binding.  <code>TFactory</code> must also derive from <code>IFactory&lt;TConcrete&gt;</code> for this to work.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Map IFoo to our custom factory Foo.Factory</span>
Container.BindIFactory&lt;IFoo&gt;().ToCustomFactory&lt;Foo, MyCustomFooFactory&gt;();

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">MyCustomFooFactory</span> : <span class="pl-k">IFactory</span>&lt;<span class="pl-k">IFoo</span>&gt;
{
    ...
}</pre></div>

<p>7 - <strong>ToPrefab(prefab)</strong> - Create dynamic MonoBehaviour using given prefab</p>

<p>Results in a dependency of type <code>IFactory&lt;TContract&gt;</code>
 that can be used to create instances of the given prefab.  After 
instantiating the given prefab, the factory will search it for a 
component of type <code>TContract</code> and then will return that from the <code>Create()</code> method.  In this case, the <code>TContract</code> class must either be an interface or derive from <code>Component</code> / <code>MonoBehaviour</code>.</p>

<div class="highlight highlight-source-cs"><pre>Container.BindIFactory&lt;IFoo&gt;().ToPrefab(prefab);</pre></div>

<h2>
<a id="user-content-custom-factories" class="anchor" href="#custom-factories" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-custom-factories"></a>Custom Factories</h2>

<p>If you do not want to use the abstract factory method as described 
above, or if you want to have 100% control of how your object is 
instantiated, you could also create a custom factory.  For example:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">enum</span> <span class="pl-en">Difficulties</span>
{
    Easy,
    Hard,
}

<span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">IEnemy</span>
{
    ...
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Demon</span> : <span class="pl-k">IEnemy</span>
{
    ...
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Dog</span> : <span class="pl-k">IEnemy</span>
{
    ...
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">EnemyFactory</span>
{
    DiContainer _container;
    Difficulties _difficulty;

    <span class="pl-k">public</span> <span class="pl-en">EnemyFactory</span>(<span class="pl-k">DiContainer</span> <span class="pl-smi">container</span>, <span class="pl-k">Difficulties</span> <span class="pl-smi">difficulty</span>)
    {
        _container = container;
        _difficulty = difficulty;
    }

    <span class="pl-k">public</span> IEnemy <span class="pl-en">Create</span>(<span class="pl-k">float</span> <span class="pl-smi">speed</span>)
    {
        <span class="pl-k">if</span> (_difficulty == Difficulties.Hard)
        {
            <span class="pl-k">return</span> _container.Instantiate&lt;Demon&gt;(speed);
        }

        <span class="pl-k">return</span> _container.Instantiate&lt;Dog&gt;(speed);
    }
}</pre></div>

<p>And then in our installer we would include:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;EnemyFactory&gt;().ToSingle();
Container.Bind&lt;Difficulties&gt;().ToInstance(Difficulties.Easy);</pre></div>

<p>This way we can change the type of enemy we spawn by simply changing the difficulty bound in the installer.</p>

<p>Or, if you do not want your code to depend on <code>EnemyFactory</code> directly, you could change it to this instead:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">EnemyFactory</span> : <span class="pl-k">IFactory</span>&lt;<span class="pl-k">IEnemy</span>&gt;
{
    ...
}

...

Container.BindIFactory&lt;IEnemy&gt;().ToCustomFactory&lt;EnemyFactory&gt;();</pre></div>

<p>Note also that this is equivalent to the following:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFactory&lt;IEnemy&gt;&gt;().ToTransient&lt;EnemyFactory&gt;();</pre></div>

<p>One issue with the above implementations is that they will not be 
validated properly.  Any constructor parameters added to the Dog or 
Demon classes that cannot be resolved will not be detected until 
runtime.  If you wish to address this you can implement it the following
 way:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">EnemyFactory</span> : <span class="pl-k">IValidatable</span>
{
    DiContainer _container;
    Difficulties _difficulty;

    <span class="pl-k">public</span> <span class="pl-en">EnemyFactory</span>(<span class="pl-k">DiContainer</span> <span class="pl-smi">container</span>, <span class="pl-k">Difficulties</span> <span class="pl-smi">difficulty</span>)
    {
        _container = container;
        _difficulty = difficulty;
    }

    <span class="pl-k">public</span> IEnemy <span class="pl-en">Create</span>(<span class="pl-k">float</span> <span class="pl-smi">speed</span>)
    {
        <span class="pl-k">if</span> (_difficulty == Difficulties.Hard)
        {
            <span class="pl-k">return</span> _container.Instantiate&lt;Demon&gt;(speed);
        }

        <span class="pl-k">return</span> _container.Instantiate&lt;Dog&gt;(speed);
    }

    <span class="pl-k">public</span> IEnumerable&lt;ZenjectResolveException&gt; <span class="pl-en">Validate</span>()
    {
        <span class="pl-k">return</span> _container.ValidateObjectGraph&lt;Dog&gt;(<span class="pl-k">typeof</span>(<span class="pl-k">float</span>))
            .Concat(_container.ValidateObjectGraph&lt;Demon&gt;(<span class="pl-k">typeof</span>(<span class="pl-k">float</span>)));
    }
}</pre></div>

<p>This is optional but can be nice if you are fan of validation.  The 
parameters provided to the ValidateObjectGraph method indicate the 
dependencies that can be skipped for validation.  This should include 
any runtime parameters.</p>

<p>Note that we are injecting the DiContainer directly into the 
EnemyFactory class, which is generally a bad thing to do but ok in this 
case because it is a factory (and therefore part of the "composition 
root layer")</p>

<p>For another real world example on factories, see <a href="https://www.reddit.com/r/Zenject/comments/3brroe/questionsimple_ftg_with_mvc_pattern/">this reddit thread</a></p>

<h2>
<a id="user-content-injecting-data-across-scenes" class="anchor" href="#injecting-data-across-scenes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-injecting-data-across-scenes"></a>Injecting data across scenes</h2>

<p>In some cases it's useful to pass arguments from one scene to 
another.  The way Unity allows us to do this by default is fairly 
awkward.  Your options are to create a persistent GameObject and call 
DontDestroyOnLoad() to keep it alive when changing scenes, or use global
 static classes to temporarily store the data.</p>

<p>Let's pretend you want to specify a 'level' string to the next scene.  You have the following class that requires the input:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">LevelHandler</span> : <span class="pl-k">IInitializable</span>
{
    <span class="pl-k">readonly</span> <span class="pl-k">string</span> _startLevel;

    <span class="pl-k">public</span> <span class="pl-en">LevelHandler</span>(
        [InjectOptional(<span class="pl-s"><span class="pl-pds">"</span>StartLevelName<span class="pl-pds">"</span></span>)]
        <span class="pl-k">string</span> startLevel)
    {
        <span class="pl-k">if</span> (startLevel == <span class="pl-c1">null</span>)
        {
            _startLevel = <span class="pl-s"><span class="pl-pds">"</span>default_level<span class="pl-pds">"</span></span>;
        }
        <span class="pl-k">else</span>
        {
            _startLevel = startLevel;
        }
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Initialize</span>()
    {
        ...
        [Load level]
        ...
    }
}</pre></div>

<p>You can load the scene containing <code>LevelHandler</code> and specify a particular level by using the following syntax:</p>

<div class="highlight highlight-source-cs"><pre>ZenUtil.LoadScene(<span class="pl-s"><span class="pl-pds">"</span>NameOfSceneToLoad<span class="pl-pds">"</span></span>,
    <span class="pl-k">delegate</span> (DiContainer container)
    {
        container.Bind&lt;<span class="pl-k">string</span>&gt;(<span class="pl-s"><span class="pl-pds">"</span>StartLevelName<span class="pl-pds">"</span></span>).ToInstance(<span class="pl-s"><span class="pl-pds">"</span>custom_level<span class="pl-pds">"</span></span>).WhenInjectedInto&lt;LevelHandler&gt;();
    });</pre></div>

<p>Note that you can still run the scene directly, in which case it will
 default to using "default_level".  This is possible because we are 
using the <code>InjectOptional</code> flag.</p>

<p>An alternative and arguably cleaner way to do this would be to customize the installer itself rather than the <code>LevelHandler</code> class.  In this case we can write our <code>LevelHandler</code> class like this (without the <code>[InjectOptional]</code> flag).</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">LevelHandler</span> : <span class="pl-k">IInitializable</span>
{
    <span class="pl-k">readonly</span> <span class="pl-k">string</span> _startLevel;

    <span class="pl-k">public</span> <span class="pl-en">LevelHandler</span>(<span class="pl-k">string</span> <span class="pl-smi">startLevel</span>)
    {
        _startLevel = startLevel;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Initialize</span>()
    {
        ...
        [Load level]
        ...
    }
}</pre></div>

<p>Then, in the installer for our scene we can include the following:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GameInstaller</span> : <span class="pl-k">Installer</span>
{
    [InjectOptional]
    <span class="pl-k">public</span> <span class="pl-k">string</span> LevelName = <span class="pl-s"><span class="pl-pds">"</span>default_level<span class="pl-pds">"</span></span>;

    ...

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">InstallBindings</span>()
    {
        ...
        Container.Bind&lt;<span class="pl-k">string</span>&gt;().ToInstance(LevelName).WhenInjectedInto&lt;LevelHandler&gt;();
        ...
    }
}</pre></div>

<p>Then, instead of injecting directly into the <code>LevelHandler</code> we can inject into the installer instead.</p>

<div class="highlight highlight-source-cs"><pre>ZenUtil.LoadScene(<span class="pl-s"><span class="pl-pds">"</span>NameOfSceneToLoad<span class="pl-pds">"</span></span>,
    <span class="pl-k">delegate</span> (DiContainer container)
    {
        container.Bind&lt;<span class="pl-k">string</span>&gt;().ToInstance(<span class="pl-s"><span class="pl-pds">"</span>custom_level<span class="pl-pds">"</span></span>).WhenInjectedInto&lt;GameInstaller&gt;();
    });</pre></div>

<p>Note that in this case I didn't need to use the "LevelName" identifier since there is only one string injected into the <code>GameInstaller</code> class.</p>

<p>Some people have also found it useful to separate out content into 
different scenes and then load each scene additively using the Unity 
method <code>Application.LoadLevelAdditive</code>.  In some cases it's 
useful to have the dependencies in the new scene resolved using the 
container of the original scene.  To achieve this, you can call <code>ZenUtil.LoadSceneAdditiveWithContainer</code>
 and pass in your scene's container.  Note however that it is assumed in
 this case that the new scene does not have its own container + 
Composition Root.</p>

<h2>
<a id="user-content-scene-decorators" class="anchor" href="#scene-decorators" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-scenes-decorator"></a>Scene Decorators</h2>

<p>Scene Decorators can be used to add behaviour to another scene 
without actually changing the installers in that scene.  The usual way 
to achieve this is to use flags on MonoInstallers to conditionally add 
different bindings within the scene itself.  However the scene decorator
 approach can be cleaner sometimes because it doesn't involve changing 
the main scene.</p>

<p>For example, let's say we want to add some special keyboard shortcuts
 to our main production scene for testing purposes.  In order to do this
 using decorators, you can do the following:</p>

<ul>
<li>Create a new scene</li>
<li>Add an empty GameObject and name it 'CompositionRoot'</li>
<li>Add a 'SceneDecoratorCompositionRoot' MonoBehaviour to it</li>
<li>Type in the scene you want to 'decorate' in the 'Scene Name' field of SceneDecoratorCompositionRoot</li>
<li>Create a new C# script with the following contents, then add this 
MonoBehaviour to your scene as a gameObject, then drag it to the 
Installers property of SceneDecoratorCompositionRoot</li>
</ul>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ExampleDecoratorInstaller</span> : <span class="pl-k">DecoratorInstaller</span>
{
    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">PostInstallBindings</span>()
    {
        <span class="pl-c">// Add bindings here that you want added AFTER installing the main scene</span>

        Container.Bind&lt;ITickable&gt;().ToSingle&lt;TestHotKeysAdder&gt;();
    }

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">PreInstallBindings</span>()
    {
        <span class="pl-c">// Add bindings here that you want added BEFORE installing the main scene</span>
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">TestHotKeysAdder</span> : <span class="pl-k">ITickable</span>
{
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Tick</span>()
    {
        <span class="pl-k">if</span> (Input.GetKeyDown(KeyCode.Space))
        {
            Debug.Log(<span class="pl-s"><span class="pl-pds">"</span>Hotkey triggered!<span class="pl-pds">"</span></span>);
        }
    }
}</pre></div>

<p>If you run your scene it should now behave exactly like the scene you
 entered in 'Scene Name' except with the added functionality in your 
decorator installer.  NOTE: If the scene fails to load, it might be 
because the scene that you're decoratoring has not been added to the 
list of levels in build settings.</p>

<p>The PostInstallBindings method is useful when you want to override a 
binding in the main scene using 'Rebind'.  And PreInstallBindings is 
necessary if you want to inject data into the installers in the main 
scene. For a better example see the asteroids project that comes with 
Zenject (open 'AsteroidsDecoratorExample' scene).  NOTE:  If installing 
from asset store version, you need to add the 'Asteroids' scene to your 
build settings so that the scene decorator can find it.</p>

<p>Note also that Zenject validate (using CTRL+SHIFT+V or the menu item 
via Edit-&gt;Zenject-&gt;Validate Current Scene) also works with 
decorator scenes.</p>

<h2>
<a id="user-content-advanced-factory-construction-using-subcontainers" class="anchor" href="#advanced-factory-construction-using-subcontainers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-advanced-factory-construction-using-subcontainers"></a>Advanced Factory Construction Using SubContainers</h2>

<p>In the real world there can sometimes be complex construction that 
needs to occur in your custom factory classes.  One way to deal with 
this is to use a temporary sub-container.</p>

<p>For example, suppose one day we decide to add further runtime constructor arguments to the <code>Enemy</code> class:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Enemy</span>
{
    <span class="pl-k">public</span> <span class="pl-en">Enemy</span>(<span class="pl-k">EnemyWeapon</span> <span class="pl-smi">weapon</span>)
    {
        ...
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">EnemyWeapon</span>
{
    <span class="pl-k">public</span> <span class="pl-en">EnemyWeapon</span>(<span class="pl-k">float</span> <span class="pl-smi">damage</span>)
    {
        ...
    }
}</pre></div>

<p>And let's say we want the damage of the <code>EnemyWeapon</code> class to be specified by the <code>EnemySpawner</code> class.  How do we pass that argument down to <code>EnemyWeapon</code>?  In this case it might be easiest to create the <code>EnemyWeapon</code> class first and then pass it to the factory.  However, for the sake of this example let's pretend we want to create the <code>Enemy</code> class in one call to <code>Instantiate()</code>.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">EnemyFactory</span>
{
    DiContainer _container;

    <span class="pl-k">public</span> <span class="pl-en">EnemyFactory</span>(<span class="pl-k">DiContainer</span> <span class="pl-smi">container</span>)
    {
        _container = container;
    }

    <span class="pl-k">public</span> Enemy <span class="pl-en">Create</span>(<span class="pl-k">float</span> <span class="pl-smi">weaponDamage</span>)
    {
        DiContainer subContainer = Container.CreateSubContainer();
        subContainer.BindInstance(weaponDamage).WhenInjectedInto&lt;EnemyWeapon&gt;();
        <span class="pl-k">return</span> subContainer.Instantiate&lt;Enemy&gt;();
    }
}</pre></div>

<p>We can use Sub-Containers here to achieve this.  Sub-containers can 
be used in factories to add complex bindings to the object graph that 
you are instantiating.  The <code>Container.Instantiate</code> method 
does allow passing in a list of constructor arguments, but it is limited
 to just that.  Using Sub-Containers in this way can be thought of a 
more powerful version of that.  Though of course, Sub-Containers have a 
lot more uses than simply factory construction, as explained in the <a href="#sub-containers-and-facades">next section</a></p>

<h2>
<a id="user-content-sub-containers-and-facades" class="anchor" href="#sub-containers-and-facades" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-sub-containers-and-facades"></a>Sub-Containers And Facades</h2>

<p>In some cases it can be very useful to use multiple containers in the
 same application.  For example, if you are creating a word processor it
 may be useful to have a sub-container for each tab that represents a 
separate document.  This way, you could bind a bunch of classes <code>ToSingle()</code>
 within the sub-container and they could all easily reference each other
 as if they were all singletons.  Then you could instantiate multiple 
sub-containers to be used for each document, with each sub-container 
having unique instances of all the classes that handle each specific 
document.</p>

<p>Another example might be if you are designing an open-world space 
ship game, you might want each space ship to have it's own container 
that contains all the class instances responsible for running that 
specific spaceship.</p>

<p>This is actually how global bindings work.  There is one global 
container for the entire application, and when a unity scene starts up, 
it creates a new sub-container "underneath" the global container.  All 
the bindings that you add in your scene MonoInstaller are bound to your 
sub-container.  This allows the dependencies in your scene to 
automatically get injected with global bindings, because sub-containers 
automatically inherit all the bindings in its parent (and grandparent, 
etc.).</p>

<p>A common design pattern that we like to use in relation to sub-containers is the <a href="https://en.wikipedia.org/wiki/Facade_pattern">Facade pattern</a>.
  This pattern is used to abstract away a related group of dependencies 
so that it can be used at a higher level when used by other modules in 
the code base.  This is relevant here because often when you are 
defining sub-containers in your application it is very useful to also 
define a Facade class that is used to interact with this sub-container 
as a whole.  So, to apply it to the spaceship example above, you might 
have a SpaceshipFacade class that represents very high-level operations 
on a spaceship such as "Start Engine", "Take Damage", "Fly to 
destination", etc.  And then internally, the SpaceshipFacade class can 
delegate the specific handling of all the parts of these requests to the
 relevant single-responsibility dependencies that exist within the 
sub-container.  Let's see what the code would look like in this example 
(read the comments for an explanation)</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// First we define our facade class to represent all the classes associated with a ship</span>
<span class="pl-c">// Facade is a class that is built into Zenject</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ShipFacade</span> : <span class="pl-k">Facade</span>
{
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Factory</span> : <span class="pl-k">FacadeFactory</span>&lt;<span class="pl-k">ShipFacade</span>&gt;
    {
    }
}

<span class="pl-c">// Now we define a few classes that will be installed into our ship sub-container</span>
<span class="pl-c">// This class will just move the ship in a specific direction</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ShipMoveHandler</span> : <span class="pl-k">ITickable</span>
{
    <span class="pl-k">readonly</span> Settings _settings;

    ShipView _view;
    Vector3 _direction = Vector3.forward;

    <span class="pl-k">public</span> <span class="pl-en">ShipMoveHandler</span>(
        <span class="pl-k">ShipView</span> <span class="pl-smi">view</span>,
        <span class="pl-k">Settings</span> <span class="pl-smi">settings</span>)
    {
        _settings = settings;
        _view = view;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Tick</span>()
    {
        _view.transform.position += _direction * _settings.Speed * Time.deltaTime;
    }

    [Serializable]
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Settings</span>
    {
        <span class="pl-k">public</span> <span class="pl-k">float</span> Speed;
    }
}

<span class="pl-c">// We define an empty monobehaviour that will allow us to manipulate the game object</span>
<span class="pl-c">// that contains the ship mesh, animations, etc.</span>
<span class="pl-c">// This would normally contain references to all the different parts of the model that we're</span>
<span class="pl-c">// interested in</span>
<span class="pl-c">// It is attached to the prefab that we install below in GameInstaller</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ShipView</span> : <span class="pl-k">MonoBehaviour</span>
{
}

<span class="pl-c">// We also need to define a class that will contain our ship facade</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GameController</span> : <span class="pl-k">IInitializable</span>, <span class="pl-k">ITickable</span>
{
    <span class="pl-k">readonly</span> ShipFacade.Factory _shipFactory;
    ShipFacade _ship;

    <span class="pl-k">public</span> <span class="pl-en">GameController</span>(<span class="pl-k">ShipFacade.Factory</span> <span class="pl-smi">shipFactory</span>)
    {
        _shipFactory = shipFactory;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Initialize</span>()
    {
        <span class="pl-c">// Note that all the IInitializable's will automatically have their Initialize</span>
        <span class="pl-c">// methods call here so there is no need to do it ourselves</span>
        _ship = _shipFactory.Create();
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Tick</span>()
    {
        <span class="pl-c">// However, the facade class must have its Tick() called manually</span>
        <span class="pl-c">// in order to have any ITickable's in the container get their Tick() methods called</span>
        _ship.Tick();
    }
}

<span class="pl-c">// Finally, we install everything!</span>
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GameInstaller</span> : <span class="pl-k">MonoInstaller</span>
{
    [SerializeField]
    Settings _settings;

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">InstallBindings</span>()
    {
        <span class="pl-c">// Add our main game class</span>
        Container.Bind&lt;IInitializable&gt;().ToSingle&lt;GameController&gt;();
        Container.Bind&lt;ITickable&gt;().ToSingle&lt;GameController&gt;();
        Container.Bind&lt;GameController&gt;().ToSingle();

        <span class="pl-c">// This will result in a binding of type ShipFacade.Factory</span>
        <span class="pl-c">// Note that you can add conditions to this just like for other bindings</span>
        Container.BindFacadeFactory&lt;ShipFacade, ShipFacade.Factory&gt;(InstallShipFacade);

        <span class="pl-c">// This could be either bound in the subcontainer or in the main container, it doesn't matter</span>
        Container.BindInstance(_settings.ShipMoveHandler);
    }

    <span class="pl-c">// This method will be called to initialize the container every time a new ship is created</span>
    <span class="pl-k">void</span> <span class="pl-en">InstallShipFacade</span>(<span class="pl-k">DiContainer</span> <span class="pl-smi">subContainer</span>)
    {
        <span class="pl-c">// Note here that we are using subContainer and NOT Container</span>
        subContainer.Bind&lt;ITickable&gt;().ToSingle&lt;ShipMoveHandler&gt;();
        subContainer.Bind&lt;ShipView&gt;().ToSinglePrefab(_settings.ShipPrefab);
    }

    [Serializable]
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Settings</span>
    {
        <span class="pl-k">public</span> GameObject ShipPrefab;
        <span class="pl-k">public</span> ShipMoveHandler.Settings ShipMoveHandler;
    }
}</pre></div>

<p>By doing the above we can now easily create multiple ship facade's 
and this will result in new instances of ship-handling classes such as <code>ShipMoveHandler</code>
 being created for each individual ship.  And within the ship 
subcontainer, all these classes can treat each other as singletons.  
This is very nice, because just like in other examples above, when 
writing new classes to handle the ship, we don't need to think about 
where our dependencies come from, we just need to worry about fulfilling
 our own single responsibilities and then ask for whatever other 
dependencies we need in our constructor.</p>

<p>Finally, we can also operate on each individual ship from the main 
game code by interacting with the ShipFacade, which abstracts away the 
low level functionality from within the ship.</p>

<p>This is a simple example.  In the real-world, almost all facades will
 take some parameters.  This can be done in a similar way to how 
parameters are added to the other kinds of factories.   For example, 
let's say we want to construct the "ShipView" class outside of the 
facade and then pass that into it.  To make things a bit more 
interesting, let's also add a high-level method on the ShipFacade.</p>

<p>The code would then just need to be changed to the following:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ShipFacade</span> : <span class="pl-k">Facade</span>
{
    ShipMoveHandler _moveHandler;

    <span class="pl-c">// Note that the facade class is itself created from inside the subcontainer</span>
    <span class="pl-c">// and therefore can add dependencies for any of its contents</span>
    <span class="pl-k">public</span> <span class="pl-en">ShipFacade</span>(<span class="pl-k">ShipMoveHandler</span> <span class="pl-smi">moveHandler</span>)
    {
        _moveHandler = moveHandler;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">StartEngine</span>()
    {
        <span class="pl-c">// Delegate to the engine handler</span>
        _moveHandler.StartEngine();
    }

    <span class="pl-c">// Add any parameters that we want to take from outside to the list here</span>
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Factory</span> : <span class="pl-k">FacadeFactory</span>&lt;<span class="pl-k">ShipView</span>, <span class="pl-k">ShipFacade</span>&gt;
    {
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ShipView</span> : <span class="pl-k">MonoBehaviour</span>
{
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Factory</span> : <span class="pl-k">GameObjectFactory</span>&lt;<span class="pl-k">ShipView</span>&gt;
    {
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GameController</span> : <span class="pl-k">IInitializable</span>, <span class="pl-k">ITickable</span>
{
    <span class="pl-k">readonly</span> ShipFacade.Factory _shipFactory;
    <span class="pl-k">readonly</span> ShipView.Factory _shipViewFactory;
    ShipFacade _ship;

    <span class="pl-k">public</span> <span class="pl-en">GameController</span>(<span class="pl-k">ShipFacade.Factory</span> <span class="pl-smi">shipFactory</span>, <span class="pl-k">ShipView.Factory</span> <span class="pl-smi">shipViewFactory</span>)
    {
        _shipFactory = shipFactory;
        _shipViewFactory = shipViewFactory;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Initialize</span>()
    {
        <span class="pl-k">var</span> shipView = _shipViewFactory.Create();

        ...

        _ship = _shipFactory.Create(shipView);

        ....

        _ship.StartEngine();
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Tick</span>()
    {
        _ship.Tick();
    }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GameInstaller</span> : <span class="pl-k">MonoInstaller</span>
{
    [SerializeField]
    Settings _settings;

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> <span class="pl-en">InstallBindings</span>()
    {
        Container.Bind&lt;IInitializable&gt;().ToSingle&lt;GameController&gt;();
        Container.Bind&lt;ITickable&gt;().ToSingle&lt;GameController&gt;();
        Container.Bind&lt;GameController&gt;().ToSingle();

        Container.BindGameObjectFactory&lt;ShipView.Factory&gt;(_settings.ShipPrefab);
        Container.BindFacadeFactory&lt;ShipView, ShipFacade, ShipFacade.Factory&gt;(InstallShipFacade);

        Container.BindInstance(_settings.ShipMoveHandler);
    }

    <span class="pl-c">// Any parameters passed to the factory are then forwarded to this method</span>
    <span class="pl-c">// This allows us to bind the parameters however we want</span>
    <span class="pl-c">// This also allows us to conditionally add different bindings depending on the parameter values</span>
    <span class="pl-k">void</span> <span class="pl-en">InstallShipFacade</span>(<span class="pl-k">DiContainer</span> <span class="pl-smi">subContainer</span>, <span class="pl-k">ShipView</span> <span class="pl-smi">view</span>)
    {
        subContainer.BindInstance(view);
        subContainer.Bind&lt;ITickable&gt;().ToSingle&lt;ShipMoveHandler&gt;();
    }

    [Serializable]
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Settings</span>
    {
        <span class="pl-k">public</span> GameObject ShipPrefab;
        <span class="pl-k">public</span> ShipMoveHandler.Settings ShipMoveHandler;
    }
}</pre></div>

<p>If you find yourself using a lot of sub-containers / facades, you may
 find yourself in a situation where you want to inject a dependency from
 the parent container, or you want to explicitly not inject from the 
parent container.  For these cases you can pass an extra parameter to 
the <code>[Inject]</code> attribute to specify this.  For example, the following will guarantee that the <code>Bar</code> dependencies always comes from the same container that <code>Foo</code> is created in.</p>

<pre><code>class Foo
{
    public Bar val;

    public Foo(
        [Inject(InjectSources.Local)]
        Bar val)
    {
        this.val = val;
    }
}
</code></pre>

<p><code>InjectSources</code> can be any of the following.  Note that <code>Any</code> is the default when unspecified.</p>

<ul>
<li>
<code>Any</code> - Current Container or any parent</li>
<li>
<code>Local</code> - Inject strictly from the current container and ignore any parent dependencies</li>
<li>
<code>Parent</code> - Inject strictly from the immediate parent 
container and ignore any dependency matches in the current container or 
grant-parent container</li>
<li>
<code>AnyParent</code> - Inject from any parent, but ignore the current container.</li>
</ul>

<h2>
<a id="user-content-commands-and-signals" class="anchor" href="#commands-and-signals" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-commands-and-signals"></a>Commands And Signals</h2>

<p>Zenject also includes an optional extension that allows you to define "Commands" and "Signals".</p>

<p>A signal can be thought of as a single event, that when triggered 
will notify a number of listeners.  A command is an object with a single
 method named <code>Execute</code>, that will forward the request to a specific handler.</p>

<p>The advantage of using Signals and Commands is that the result will 
often be more loosely coupled code.  Given two classes A and B that need
 to communicate, your options are usually:</p>

<ol>
<li>Directly call a method on B from A.  In this case, A is strongly coupled with B.</li>
<li>Inverse the dependency by having B observe an event on A.  In this case, B is strongly coupled with A.</li>
</ol>

<p>Both cases result in the classes being coupled in some way.  Now if 
instead you create a command object, which is called by A and which 
invokes a method on B, then the result is less coupling.  Granted, A is 
still coupled to the command class, but in some cases that is better 
than being directly coupled to B.  Using signals works similarly, in 
that you can remove the coupling by having A trigger a signal, which is 
observed by B.</p>

<p>Signals are defined like this:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GameLoadedSignal</span> : <span class="pl-k">Signal</span>
{
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Trigger</span> : <span class="pl-k">TriggerBase</span> { }
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">GameLoadedSignalWithParameter</span> : <span class="pl-k">Signal</span>&lt;<span class="pl-k">string</span>&gt;
{
    <span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Trigger</span> : <span class="pl-k">TriggerBase</span> { }
}</pre></div>

<p>The trigger class is used to invoke the signal event.  We make the 
trigger a separate class so that we can control which classes can 
trigger the signal and which classes can listen on the signal 
separately.</p>

<p>Note that the Signal base class is defined within the Zenject.Commands namespace.</p>

<p>Signals are declared in an installer like this:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> InstallBindings()
{
    ...
    Container.BindSignal&lt;GameLoadedSignal&gt;();
    ...
    Container.BindSignal&lt;GameLoadedSignalWithParameter, <span class="pl-k">string</span>&gt;().WhenInjectedInto&lt;Foo&gt;();
}
</pre></div>

<p>These statements will do the following:</p>

<ul>
<li>Bind the class <code>GameLoadedSignal</code> as <code>ToSingle&lt;&gt;</code> without a condition.  This means that any class can declare <code>GameLoadedSignal</code> as a dependency.</li>
<li>Bind the class <code>GameLoadedSignalWithParameter</code> as <code>ToSingle&lt;&gt;</code> as well, except it will limit its usage strictly to class <code>Foo</code>.</li>
</ul>

<p>Once you have added the signal to your container by binding it within an installer, you can use it like this:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span> : <span class="pl-k">IInitializable</span>, <span class="pl-k">IDisposable</span>
{
    <span class="pl-k">readonly</span> GameLoadedSignal _signal;

    <span class="pl-k">public</span> <span class="pl-en">Foo</span>(<span class="pl-k">GameLoadedSignal</span> <span class="pl-smi">signal</span>)
    {
        _signal = signal;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Initialize</span>()
    {
        _signal.Event += OnGameLoaded;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Dispose</span>()
    {
        _signal.Event -= OnGameLoaded;
    }

    <span class="pl-k">void</span> <span class="pl-en">OnGameLoaded</span>()
    {
        ...
    }
}</pre></div>

<p>Here we use the convention of prefixing event handlers with On, but of course you don't have to follow this convention.</p>

<p>After binding the signal, you will almost always want to also bind a 
trigger, so that you can actually invoke the signal.  Signals and 
Triggers are bound as separate statements so that you can optionally add
 conditional binding on both the trigger and the signal separately.</p>

<p>Triggers are declared in an installer like this:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> InstallBindings()
{
    ...
    Container.BindTrigger&lt;GameLoadedSignal.Trigger&gt;();
    ...
    Container.BindTrigger&lt;GameLoadedSignalWithParameter.Trigger, <span class="pl-k">string</span>&gt;().WhenInjectedInto&lt;Foo&gt;();
}
</pre></div>

<p>Once you have added the trigger to your container by binding it within an installer, you can use it like this:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>
{
    <span class="pl-k">readonly</span> GameLoadedSignal.Trigger _trigger;

    <span class="pl-k">public</span> <span class="pl-en">Foo</span>(<span class="pl-k">GameLoadedSignal.Trigger</span> <span class="pl-smi">trigger</span>)
    {
        _trigger = trigger;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">DoSomething</span>()
    {
        _trigger.Fire();
    }
}</pre></div>

<p>Commands are defined like this</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ResetSceneCommand</span> : <span class="pl-k">Command</span> { }

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ResetSceneCommandWithParameter</span> : <span class="pl-k">Command</span>&lt;<span class="pl-k">string</span>&gt; { }</pre></div>

<p>Note again that the Command base class is defined within the Zenject.Commands namespace here.</p>

<p>Unlike with signals, there are several different ways of declaring a 
command in an installer.  Perhaps the simplest way would be the 
following:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> InstallBindings()
{
    ...
    Container.BindCommand&lt;ResetSceneCommand&gt;().HandleWithSingle&lt;ResetSceneHandler&gt;();
    ...
    Container.BindCommand&lt;ResetSceneCommandWithParameter, <span class="pl-k">string</span>&gt;().HandleWithSingle&lt;ResetSceneHandler&gt;();
    ...
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ResetSceneHandler</span> : <span class="pl-k">ICommandHandler</span>
{
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Execute</span>()
    {
        ... [reset scene] ...
    }
}</pre></div>

<p>This bind statement will result in an object of type <code>ResetSceneCommand</code> being added to the container.  Any time a class calls Execute on <code>ResetSceneCommand</code>, it will trigger the Execute method on the <code>ResetSceneHandler</code> class as well.  For example:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span> : <span class="pl-k">ITickable</span>
{
    <span class="pl-k">readonly</span> ResetSceneCommand _command;

    <span class="pl-k">public</span> <span class="pl-en">Foo</span>(<span class="pl-k">ResetSceneCommand</span> <span class="pl-smi">command</span>)
    {
        _command = command;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Tick</span>()
    {
        ...
        _command.Execute();
        ...
    }
}</pre></div>

<p>We might also want to restrict usage of our command to the Foo class only, which we could do with the following</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> InstallBindings()
{
    ...
    Container.BindCommand&lt;ResetSceneCommand&gt;().HandleWithSingle&lt;ResetSceneHandler&gt;().WhenInjectedInto&lt;Foo&gt;();
    ...
}</pre></div>

<p>Note that in this case we are using <code>HandleWithSingle&lt;&gt;</code> - this means that the same instance of <code>ResetSceneHandler</code> will be used every time the command is executed.  Alternatively, you could declare it using <code>HandleWithTransient&lt;&gt;</code> which would instantiate a new instance of <code>ResetSceneHandler</code> every time Execute() is called.  For example:</p>

<div class="highlight highlight-source-cs"><pre>Container.BindCommand&lt;ResetSceneCommand&gt;().HandleWithTransient&lt;ResetSceneHandler&gt;();</pre></div>

<p>This might be useful if the <code>ResetSceneCommand</code> class involves some long-running operations that require unique sets of member variables/dependencies.</p>

<p>You can also bind commands directly to methods instead of classes by doing the following:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">void</span> InstallBindings()
{
    ...
    Container.BindCommand&lt;ResetSceneCommand&gt;().HandleWithSingle&lt;MyOtherHandler&gt;(x =&gt; x.ResetScene);
    ...
}

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">ResetSceneHandler</span>
{
    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">ResetScene</span>()
    {
        ... [reset scene] ...
    }
}</pre></div>

<p>This approach does not require that you derive from <code>ICommandHandler</code> at all.  There is also a <code>HandleWithTransient</code> version of this which works similarly (instantiates a new instance of MyOtherHandler).</p>

<div class="highlight highlight-source-cs"><pre>Container.BindCommand&lt;ResetSceneCommand&gt;().HandleWithTransient&lt;MyOtherHandler&gt;(x =&gt; x.ResetScene);</pre></div>

<h2>
<a id="user-content-automatic-bindings" class="anchor" href="#automatic-bindings" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-autobind"></a>Automatic Bindings</h2>

<p>In many cases, you have a number of MonoBehaviour's that have been 
added to the scene within the Unity editor (ie. at editor time not 
runtime) and you want to also have these MonoBehaviour's added to the 
Zenject Container so that they can be injected into other classes.</p>

<p>The usual way this is done is to add public references to these objects within your installer like this:</p>

<pre><code>public class Foo : MonoBehaviour
{
}

public class GameInstaller : MonoInstaller
{
    [SerializeField]
    Foo _foo;

    public override void InstallBindings()
    {
        Container.BindInstance(_foo);
        Container.Bind&lt;IInitializable&gt;().ToSingle&lt;GameRunner&gt;();
    }
}

public class GameRunner : IInitializable
{
    readonly Foo _foo;

    public GameRunner(Foo foo)
    {
        _foo = foo;
    }

    public void Initialize()
    {
        ...
    }
}
</code></pre>

<p>(Note that you could also just make <code>Foo</code> public here - my personal convention is to just always use <code>SerializeField</code> instead to avoid breaking encapsulation)</p>

<p>This works fine however in some cases this can get cumbersome.  For 
example, if you want to allow an artist to add any number of <code>Enemy</code> objects to the scene, and you also want all those <code>Enemy</code>
 objects added to the Zenject Container.  In this case, you would have 
to manually drag each one to the inspector of one of your installers.  
This is very error prone since its easy to forget one, or to delete the <code>Enemy</code> game object but forget to delete the null reference in the inspector for your installer, etc.</p>

<p>So another way to do this is to use the <code>AutoBindInstaller</code>.  You can do this by adding a <code>ZenjectAutoBinding</code> monobehaviour to the same game object that you want to be automatically added to the Zenject container.</p>

<p>For example, if I have a MonoBehaviour of type <code>Foo</code> in my scene, I can just add <code>ZenjectAutoBinding</code> alongside it:</p>

<p><a href="http://localhost:6419/UnityProject/Assets/Zenject/Documentation/Images/AutoBind1.png?raw=true" target="_blank"><img src="ReadMe_files/AutoBind1.png" alt="ZenjectAutoBinding" style="max-width:100%;"></a></p>

<p>Then our installer becomes:</p>

<pre><code>public class GameInstaller : MonoInstaller
{
    public override void InstallBindings()
    {
        Container.Install&lt;AutoBindInstaller&gt;();
        Container.Bind&lt;IInitializable&gt;().ToSingle&lt;GameRunner&gt;();
    }
}
</code></pre>

<p>Note that when using the <code>ZenjectAutoBinding</code> MonoBehaviour you always need to add <code>Container.Install&lt;AutoBindInstaller&gt;()</code> to one of the installers in your scene.</p>

<p>When using <code>ZenjectAutoBinding</code> this way, by default it will bind <code>Foo</code> using the <code>ToInstance</code> method, so it is equivalent to the first example where we did this:</p>

<pre><code>Container.BindInstance(_foo);
</code></pre>

<p>Also note that if we duplicate this game object to have multiple game objects with <code>Foo</code> on them (and its <code>ZenjectAutoBinding</code>), they will all be bound to the Container this way.  So after doing this, we would have to change <code>GameRunner</code> above to take a <code>List&lt;Foo&gt;</code> otherwise we would get Zenject exceptions.</p>

<p>Also note that the <code>ZenjectAutoBinding</code> component contains a <code>Bind Type</code> property in its inspector.  By default this simply binds the instance as shown above but it can also be set to the following:</p>

<p>1 - <code>ToInterfaces</code></p>

<p>This bind type is equivalent to the following:</p>

<pre><code>Container.BindAllInterfacesToInstance(_foo);
</code></pre>

<p>Note however, in this case, that <code>GameRunner</code> must ask for type <code>IFoo</code> in its constructor.  If we left <code>GameRunner</code> asking for type <code>Foo</code> then Zenject would throw exceptions, since the <code>BindAllInterfacesToInstance</code> method only binds the interfaces, not the concrete type.  If you want the concrete type as well then you can use:</p>

<p>2 - <code>ToInstanceAndInterfaces</code></p>

<p>This bind type is equivalent to the following:</p>

<pre><code>Container.BindAllInterfacesToInstance(_foo);
Container.BindInstance(_foo);
</code></pre>

<h2>
<a id="user-content-auto-mocking-using-moq" class="anchor" href="#auto-mocking-using-moq" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-auto-mocking-using-moq"></a>Auto-Mocking using Moq</h2>

<p>One of the really cool features of DI is the fact that it makes 
testing code much, much easier.  This is because you can easily 
substitute one dependency for another by using a different Composition 
Root.  For example, if you only want to test a particular class (let's 
call it Foo) and don't care about testing its dependencies, you might 
write 'mocks' for them so that you can isolate Foo specifically.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>
{
    IWebServer _webServer;

    <span class="pl-k">public</span> <span class="pl-en">Foo</span>(<span class="pl-k">IWebServer</span> <span class="pl-smi">webServer</span>)
    {
        _webServer = webServer;
    }

    <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">Initialize</span>()
    {
        ...
        <span class="pl-k">var</span> x = _webServer.GetSomething();
        ...
    }
}</pre></div>

<p>In this example, we have a class Foo that interacts with a web server
 to retrieve content.  This would normally be very difficult to test for
 the following reasons:</p>

<ul>
<li>You would have to set up an environment where it can properly connect to a web server (configuring ports, urls, etc.)</li>
<li>Running the test could be slower and limit how much testing you can do</li>
<li>The web server itself could contain bugs so you couldn't with certainty isolate Foo as the problematic part of the test</li>
<li>You can't easily configure the values returned from the web server to test sending various inputs to the Foo class</li>
</ul>

<p>However, if we create a mock class for IWebServer then we can address all these problems:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">MockWebServer</span> : <span class="pl-k">IWebServer</span>
{
    ...
}</pre></div>

<p>Then hook it up in our installer:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IWebServer&gt;().ToSingle&lt;MockWebServer&gt;();</pre></div>

<p>Then you can implement the fields of the IWebServer interface and 
configure them based on what you want to test on Foo. Hopefully You can 
see how this can make life when writing tests much easier.</p>

<p>Zenject also allows you to even avoid having to write the 
MockWebServer class in favour of using a library called "Moq" which does
 all the work for you.</p>

<p>Note that by default, Auto-mocking is not enabled in Zenject.  If you
 wish to use the auto-mocking feature then you need to go to your 
Zenject install directory and extract the contents of 
"Extras/ZenjectAutoMocking.zip".  Note also that AutoMocking is 
incompatible with webplayer builds, and you will also need to change 
your "Api Compatibility Level" from ".NET 2.0 Subset" to ".NET 2.0" (you
 can find this in PC build settings)</p>

<p>After extracting the auto mocking package it is just a matter of 
using the following syntax to mock out various parts of your project:</p>

<div class="highlight highlight-source-cs"><pre>Container.Bind&lt;IFoo&gt;().ToMock();</pre></div>

<p>However, this approach will not allow you to take advantage of the 
advanced features of Moq.  For more advanced usages, see the 
documentation for Moq</p>

<h2>
<a id="user-content-frequently-asked-questions" class="anchor" href="#frequently-asked-questions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-questions"></a>Frequently Asked Questions</h2>

<ul>
<li>
<p><strong><a id="user-content-aot-support"></a>Does this work on AOT platforms such as iOS and WebGL?</strong></p>

<p>Yes.  However, there are a few things that you should be aware of for
 WebGL.  One of the things that Unity's IL2CPP compiler does is strip 
out any code that is not used.  It calculates what code is used by 
statically analyzing the code to find usage.  This is great, except that
 this will miss any methods/types that are not used explicitly.  In 
particular, any classes that are created solely through Zenject will 
have their constructors ignored by the IL2CPP compiler.  In order to 
address this, the [Inject] attribute that is sometimes applied to 
constructors also serves to automatically mark the constructor to IL2CPP
 to not strip out.   In other words, to fix this issue all you have to 
do is mark every constructor that you create through Zenject with an 
[Inject] attribute when compiling for WebGL.</p>
</li>
<li>
<p><strong><a id="user-content-faq-performance"></a>How is performance?</strong></p>

<p>DI can affect start-up time when it builds the initial object graph. 
However it can also affect performance any time you instantiate new 
objects at run time.</p>

<p>Zenject uses C# reflection which is typically slow, but in Zenject 
this work is cached so any performance hits only occur once for each 
class type.  In other words, Zenject avoids costly reflection operations
 by making a trade-off between performance and memory to ensure good 
performance.</p>

<p>For some benchmarks on Zenject versus other DI frameworks, see <a href="https://github.com/svermeulen/IocPerformance/tree/Zenject">here</a>.</p>

<p>Zenject should also produce zero per-frame heap allocations.</p>
</li>
<li>
<p><strong><a id="user-content-net-framework"></a>Can I use .NET framework 4.0 and above?</strong></p>

<p>By default Unity uses .NET framework 3.5 and so Zenject assumes that 
this is what you want.  If you are compiling Zenject with a version 
greater than this, this is fine, but you'll have to either delete or 
comment out the contents of Func.cs.</p>
</li>
</ul>

<h2>
<a id="user-content-installers-cheat-sheet" class="anchor" href="#installers-cheat-sheet" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-cheatsheet"></a>Installers Cheat-Sheet</h2>

<p>Below are a bunch of randomly assorted examples of bindings that you might include in one of your installers.</p>

<p>For more examples, you may also be interested in reading some of the Unit tests (see <code>Zenject/OptionalExtras/UnitTests</code> directory)</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">///////////// ToTransient</span>

<span class="pl-c">// Create a new instance of Foo for every class that asks for it</span>
Container.Bind&lt;Foo&gt;().ToTransient();

<span class="pl-c">// Create a new instance of Foo for every class that asks for an IFoo</span>
Container.Bind&lt;IFoo&gt;().ToTransient&lt;Foo&gt;();

<span class="pl-c">// Non generic versions</span>
Container.Bind(<span class="pl-k">typeof</span>(IFoo)).ToTransient();
Container.Bind(<span class="pl-k">typeof</span>(IFoo)).ToTransient(<span class="pl-k">typeof</span>(Foo));

<span class="pl-c">///////////// ToSingle</span>

<span class="pl-c">// Create one definitive instance of Foo and re-use that for every class that asks for it</span>
Container.Bind&lt;Foo&gt;().ToSingle();

<span class="pl-c">// Create one definitive instance of Foo and re-use that for every class that asks for IFoo</span>
Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo&gt;();

<span class="pl-c">// In this example, the same instance of Foo will be used for all three cases</span>
Container.Bind&lt;Foo&gt;().ToSingle();
Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo&gt;();
Container.Bind&lt;IBar&gt;().ToSingle&lt;Foo&gt;();

<span class="pl-c">// Non generic versions</span>
Container.Bind(<span class="pl-k">typeof</span>(Foo)).ToSingle();
Container.Bind(<span class="pl-k">typeof</span>(IFoo)).ToSingle(<span class="pl-k">typeof</span>(Foo));

<span class="pl-c">///////////// BindAllInterfacesToSingle</span>

<span class="pl-c">// Bind all interfaces that Foo implements to a new singleton of type Foo</span>
Container.BindAllInterfacesToSingle&lt;Foo&gt;();
<span class="pl-c">// So for example if Foo implements ITickable and IInitializable then the above</span>
<span class="pl-c">// line is equivalent to this:</span>
Container.Bind&lt;ITickable&gt;().ToSingle&lt;Foo&gt;();
Container.Bind&lt;IInitializable&gt;().ToSingle&lt;Foo&gt;();

<span class="pl-c">///////////// ToInstance</span>

<span class="pl-c">// Use the given instance everywhere that Foo is used</span>
Container.Bind&lt;Foo&gt;().ToInstance(<span class="pl-k">new</span> Foo());

<span class="pl-c">// This is simply a shortcut for the above binding</span>
<span class="pl-c">// This can be a bit nicer since the type argument can be deduced from the parameter</span>
Container.BindInstance(<span class="pl-k">new</span> Foo());

<span class="pl-c">// Note that ToInstance is different from ToSingle because it does allow multiple bindings</span>
<span class="pl-c">// and you can't re-use the same instance in multiple bindings like you can with ToSingle</span>
<span class="pl-c">// For example, the following is allowed and will match any constructor parameters of type List&lt;Foo&gt;</span>
<span class="pl-c">// (and throw an exception for parameters that ask for a single Foo)</span>
Container.Bind&lt;Foo&gt;().ToInstance(<span class="pl-k">new</span> Foo());
Container.Bind&lt;Foo&gt;().ToInstance(<span class="pl-k">new</span> Foo());

<span class="pl-c">///////////// ToSingleInstance</span>

<span class="pl-c">// Use the given instance everywhere Foo is requested and ensure that it is the only Foo that is created</span>
Container.Bind&lt;Foo&gt;().ToSingleInstance(<span class="pl-k">new</span> Foo());

<span class="pl-c">// We assume here that Foo implements both IFoo and IBar</span>
<span class="pl-c">// This will result in the given instance of Foo used for all three cases</span>
Container.Bind&lt;IFoo&gt;().ToSingleInstance(<span class="pl-k">new</span> Foo());
Container.Bind&lt;IBar&gt;().ToSingle&lt;Foo&gt;();
Container.Bind&lt;Foo&gt;().ToSingle();

<span class="pl-c">///////////// Binding primitive types</span>

<span class="pl-c">// Use the number 10 every time an int is requested</span>
<span class="pl-c">// You'd never really want to do this, you should almost always use a When condition for primitive values (see conditions section below)</span>
Container.Bind&lt;<span class="pl-k">int</span>&gt;().ToInstance(<span class="pl-c1">10</span>);
Container.Bind&lt;<span class="pl-k">bool</span>&gt;().ToInstance(<span class="pl-c1">false</span>);

<span class="pl-c">// These are the same as above</span>
<span class="pl-c">// This can be a bit nicer though since the type argument can be deduced from the parameter</span>
<span class="pl-c">// Again though, be careful to use conditions to limit the scope of usage for values</span>
<span class="pl-c">// or consider using a Settings object as described above</span>
Container.BindInstance(<span class="pl-c1">10</span>);
Container.BindInstance(<span class="pl-c1">false</span>);

<span class="pl-c">///////////// ToMethod</span>

<span class="pl-c">// Create instance of Foo when requested, using the given method</span>
<span class="pl-c">// Note that for more complex construction scenarios, you might consider using a factory</span>
<span class="pl-c">// instead</span>
Container.Bind&lt;Foo&gt;().ToMethod(GetFoo);

Foo GetFoo(InjectContext ctx)
{
    <span class="pl-k">return</span> <span class="pl-k">new</span> Foo();
}

<span class="pl-c">// Randomly return one of several different implementations of IFoo</span>
<span class="pl-c">// We use Instantiate here instead of just new so that Foo1 gets its members injected</span>
Container.Bind&lt;IFoo&gt;().ToMethod(GetFoo);

IFoo GetFoo(InjectContext ctx)
{
    <span class="pl-k">switch</span> (Random.Range(<span class="pl-c1">0</span>, <span class="pl-c1">3</span>))
    {
        <span class="pl-k">case</span> <span class="pl-c1">0</span>:
            <span class="pl-k">return</span> ctx.Container.Instantiate&lt;Foo1&gt;();

        <span class="pl-k">case</span> <span class="pl-c1">1</span>:
            <span class="pl-k">return</span> ctx.Container.Instantiate&lt;Foo2&gt;();
    }

    <span class="pl-k">return</span> ctx.Container.Instantiate&lt;Foo3&gt;();
}

<span class="pl-c">// Using lambda syntax</span>
Container.Bind&lt;Foo&gt;().ToMethod((ctx) =&gt; <span class="pl-k">new</span> Foo());

<span class="pl-c">// This is equivalent to ToTransient</span>
Container.Bind&lt;Foo&gt;().ToMethod((ctx) =&gt; ctx.Container.Instantiate&lt;Foo&gt;());

<span class="pl-c">///////////// ToGetter</span>

<span class="pl-c">// Bind to a property on another dependency</span>
<span class="pl-c">// This can be helpful to reduce coupling between classes</span>
Container.Bind&lt;Foo&gt;().ToSingle();

Container.Bind&lt;Bar&gt;().ToGetter&lt;Foo&gt;(foo =&gt; foo.GetBar());

<span class="pl-c">// Another example using values</span>
Container.Bind&lt;<span class="pl-k">string</span>&gt;().ToGetter&lt;Foo&gt;(foo =&gt; foo.GetTitle());

<span class="pl-c">///////////// ToSingleGameObject</span>

<span class="pl-c">// Create a new game object at the root of the scene, add the Foo MonoBehaviour to it, and name it "Foo"</span>
Container.Bind&lt;Foo&gt;().ToSingleGameObject(<span class="pl-s"><span class="pl-pds">"</span>Foo<span class="pl-pds">"</span></span>);

<span class="pl-c">// Bind to an interface instead</span>
Container.Bind&lt;IFoo&gt;().ToSingleGameObject&lt;Foo&gt;(<span class="pl-s"><span class="pl-pds">"</span>Foo<span class="pl-pds">"</span></span>);

<span class="pl-c">///////////// ToSinglePrefab</span>

<span class="pl-c">// Create a new game object at the root of the scene using the given prefab</span>
<span class="pl-c">// It is assumed that the Foo is a MonoBehaviour here and that Foo has been</span>
<span class="pl-c">// previously added to the prefab</span>
<span class="pl-c">// After zenject creates a new GameObject from the given prefab, it will</span>
<span class="pl-c">// search the prefab for a component of type 'Foo' and return that</span>
GameObject fooPrefab;
Container.Bind&lt;Foo&gt;().ToSinglePrefab(fooPrefab);

<span class="pl-c">// Bind to interface instead</span>
Container.Bind&lt;IFoo&gt;().ToSinglePrefab&lt;Foo&gt;(fooPrefab);

<span class="pl-c">// Note that in this case only one prefab will be instantiated and re-used</span>
<span class="pl-c">// for all three bindings</span>
<span class="pl-c">// (Prefab singletons are uniquely identified by their prefab)</span>
Container.Bind&lt;Foo&gt;().ToSinglePrefab(fooPrefab);
Container.Bind&lt;IInitializable&gt;().ToSinglePrefab&lt;Foo&gt;(fooPrefab);
Container.Bind&lt;ITickable&gt;().ToSinglePrefab&lt;Foo&gt;(fooPrefab);

<span class="pl-c">///////////// ToTransientPrefab</span>

<span class="pl-c">// Instantiate a new copy of 'fooPrefab' every time an instance of Foo is</span>
<span class="pl-c">// requested by a constructor parameter, injected field, etc.</span>
GameObject fooPrefab;
Container.Bind&lt;Foo&gt;().ToTransientPrefab(fooPrefab);

<span class="pl-c">// Bind to interface instead</span>
Container.Bind&lt;IFoo&gt;().ToTransientPrefab&lt;Foo&gt;(fooPrefab);

<span class="pl-c">///////////// Identifiers</span>

<span class="pl-c">// By default this will use 'Qux' for every place that requires an instance of IFoo</span>
<span class="pl-c">// But also allow for classes to use FooA or FooB by using identifiers</span>
Container.Bind&lt;IFoo&gt;().ToSingle&lt;Qux&gt;();
Container.Bind&lt;IFoo&gt;(<span class="pl-s"><span class="pl-pds">"</span>FooA<span class="pl-pds">"</span></span>).ToSingle&lt;Bar&gt;();
Container.Bind&lt;IFoo&gt;(<span class="pl-s"><span class="pl-pds">"</span>FooB<span class="pl-pds">"</span></span>).ToSingle&lt;Baz&gt;();

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">Norf</span>
{
    <span class="pl-c">// Uses Qux</span>
    [Inject]
    IFoo _foo;

    <span class="pl-c">// Uses Bar</span>
    [Inject(<span class="pl-s"><span class="pl-pds">"</span>FooA<span class="pl-pds">"</span></span>)]
    IFoo _foo;

    <span class="pl-c">// Uses Baz if it exists, otherwise leaves it as null</span>
    [InjectOptional(<span class="pl-s"><span class="pl-pds">"</span>FooB<span class="pl-pds">"</span></span>)]
    IFoo _foo;
}

<span class="pl-c">// Bind a globally accessible string with the name 'PlayerName'</span>
<span class="pl-c">// A better option might be to create a Settings object and bind that</span>
<span class="pl-c">// instead however</span>
Container.Bind&lt;<span class="pl-k">string</span>&gt;(<span class="pl-s"><span class="pl-pds">"</span>PlayerName<span class="pl-pds">"</span></span>).ToInstance(<span class="pl-s"><span class="pl-pds">"</span>name of the player<span class="pl-pds">"</span></span>);

<span class="pl-c">///////////// Conditions</span>

<span class="pl-c">// This will only allow dependencies on Foo by the Bar class</span>
Container.Bind&lt;Foo&gt;().ToSingle().WhenInjectedInto&lt;Bar&gt;();

<span class="pl-c">// Use different implementations of IFoo dependending on which</span>
<span class="pl-c">// class is being injected</span>
Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo1&gt;().WhenInjectedInto&lt;Bar&gt;();
Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo2&gt;().WhenInjectedInto&lt;Qux&gt;();

<span class="pl-c">// Use "Foo1" as the default implementation except when injecting into</span>
<span class="pl-c">// class Qux, in which case use Foo2</span>
Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo1&gt;();
Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo2&gt;().WhenInjectedInto&lt;Qux&gt;();

<span class="pl-c">// Allow depending on Foo in only a few select classes</span>
Container.Bind&lt;Foo&gt;().ToSingle().WhenInjectedInto(<span class="pl-k">typeof</span>(Bar), <span class="pl-k">typeof</span>(Qux), <span class="pl-k">typeof</span>(Baz));

<span class="pl-c">// Supply "my game" for any strings that are injected into the Gui class with the identifier "Title"</span>
Container.BindInstance(<span class="pl-s"><span class="pl-pds">"</span>Title<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>my game<span class="pl-pds">"</span></span>).WhenInjectedInto&lt;Gui&gt;();

<span class="pl-c">// Supply 5 for all ints that are injected into the Gui class</span>
Container.BindInstance(<span class="pl-c1">5</span>).WhenInjectedInto&lt;Gui&gt;();

<span class="pl-c">// Supply 5 for all ints that are injected into a parameter or field</span>
<span class="pl-c">// inside type Gui that is named 'width'</span>
<span class="pl-c">// This is usually not a good idea since the name of a field can change</span>
<span class="pl-c">// easily and break the binding but shown here as an example  :)</span>
Container.BindInstance(<span class="pl-c1">5.0f</span>).When(ctx =&gt;
    ctx.ObjectType == <span class="pl-k">typeof</span>(Gui) &amp;&amp; ctx.MemberName == <span class="pl-s"><span class="pl-pds">"</span>width<span class="pl-pds">"</span></span>);

<span class="pl-c">// Create a new 'Foo' for every class that is created as part of the</span>
<span class="pl-c">// construction of the 'Bar' class</span>
<span class="pl-c">// So if Bar has a constructor parameter of type Qux, and Qux has</span>
<span class="pl-c">// a constructor parameter of type IFoo, a new Foo will be created</span>
<span class="pl-c">// for that case</span>
Container.Bind&lt;IFoo&gt;().ToTransient&lt;Foo&gt;().When(
    ctx =&gt; ctx.AllObjectTypes.Contains(<span class="pl-k">typeof</span>(Bar)));

<span class="pl-c">///////////// Complex conditions example</span>

<span class="pl-k">var</span> foo1 = <span class="pl-k">new</span> Foo();
<span class="pl-k">var</span> foo2 = <span class="pl-k">new</span> Foo();

Container.Bind&lt;Bar&gt;(<span class="pl-s"><span class="pl-pds">"</span>Bar1<span class="pl-pds">"</span></span>).ToTransient();
Container.Bind&lt;Bar&gt;(<span class="pl-s"><span class="pl-pds">"</span>Bar2<span class="pl-pds">"</span></span>).ToTransient();

<span class="pl-c">// Here we use the 'ParentContexts' property of inject context to sync multiple corresponding identifiers</span>
Container.BindInstance(foo1).When(c =&gt; c.ParentContexts.Where(x =&gt; x.MemberType == <span class="pl-k">typeof</span>(Bar) &amp;&amp; x.Identifier == <span class="pl-s"><span class="pl-pds">"</span>Bar1<span class="pl-pds">"</span></span>).Any());
Container.BindInstance(foo2).When(c =&gt; c.ParentContexts.Where(x =&gt; x.MemberType == <span class="pl-k">typeof</span>(Bar) &amp;&amp; x.Identifier == <span class="pl-s"><span class="pl-pds">"</span>Bar2<span class="pl-pds">"</span></span>).Any());

<span class="pl-c">// This results in:</span>
<span class="pl-c">// Container.Resolve&lt;Bar&gt;("Bar1").Foo == foo1</span>
<span class="pl-c">// Container.Resolve&lt;Bar&gt;("Bar2").Foo == foo2</span>

<span class="pl-c">///////////// ToLookup</span>

<span class="pl-c">// This will result in IBar, IFoo, and Foo, all being bound to the same instance of</span>
<span class="pl-c">// Foo which is assume to exist somewhere on the given prefab</span>
GameObject fooPrefab;
Container.Bind&lt;Foo&gt;().ToSinglePrefab(fooPrefab);
Container.Bind&lt;IBar&gt;().ToLookup&lt;Foo&gt;()
Container.Bind&lt;IFoo&gt;().ToLookup&lt;IBar&gt;()

<span class="pl-c">// This is result in the same as the above</span>
GameObject fooPrefab;
Container.Bind&lt;Foo&gt;().ToSinglePrefab(fooPrefab);
Container.Bind&lt;IBar&gt;().ToSinglePrefab&lt;Foo&gt;(fooPrefab);
Container.Bind&lt;IFoo&gt;().ToSinglePrefab&lt;Foo&gt;(fooPrefab);

<span class="pl-c">///////////// Rebind</span>

<span class="pl-c">// Rebind can be used to override previous bindings</span>
<span class="pl-c">// This will result in IFoo being bound to only Bar</span>
<span class="pl-c">// The binding to Foo will have been removed</span>
<span class="pl-c">// Normally the order that the bindings occur in doesn't</span>
<span class="pl-c">// matter at all, but Rebind does create an order-dependency</span>
<span class="pl-c">// so use with caution</span>
Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo&gt;();
Container.Rebind&lt;IFoo&gt;().ToSingle&lt;Bar&gt;();

<span class="pl-c">///////////// Installing Other Installers</span>

<span class="pl-c">// Immediately call InstallBindings() on FooInstaller</span>
Container.Install&lt;FooInstaller&gt;();

<span class="pl-c">// Before calling FooInstaller, configure a property of it</span>
Container.BindInstance(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>).WhenInjectedInto&lt;FooInstaller&gt;();
Container.Install&lt;FooInstaller&gt;();

<span class="pl-c">// After calling FooInstaller, override one of its bindings</span>
<span class="pl-c">// We assume here that FooInstaller binds IFoo to something</span>
Container.Install&lt;FooInstaller&gt;();
Container.Rebind&lt;IFoo&gt;().ToSingle&lt;Bar&gt;();

<span class="pl-c">///////////// Manual Use of Container</span>

<span class="pl-c">// This will fill in any parameters marked as [Inject] and also call the [PostInject]</span>
<span class="pl-c">// function</span>
foo = <span class="pl-k">new</span> Foo();
Container.Inject(foo);

<span class="pl-c">// Return an instance for IFoo, using the bindings that have been added previously</span>
<span class="pl-c">// Internally it is what is triggered when you fill in a constructor parameter of type IFoo</span>
<span class="pl-c">// Note: It will throw an exception if it cannot find a match</span>
Container.Resolve&lt;IFoo&gt;();

<span class="pl-c">// Same as the above except returns null when it can't find the given type</span>
Container.TryResolve&lt;IFoo&gt;();

<span class="pl-c">// Return a list of 2 instances of type Foo</span>
Container.BindInstance(<span class="pl-k">new</span> Foo());
Container.BindInstance(<span class="pl-k">new</span> Foo());
<span class="pl-k">var</span> foos = Container.ResolveAll&lt;IFoo&gt;();

<span class="pl-c">// Instantiate a new instance of Foo and inject on any of its members</span>
Container.Instantiate&lt;Foo&gt;();

<span class="pl-c">// Instantiate a new prefab and have any injectables filled in on the prefab</span>
GameObject go = Container.InstantiatePrefab(prefab);

<span class="pl-c">// Instantiate a new prefab and return a specific monobehaviour</span>
Foo foo = Container.InstantiatePrefabForComponent&lt;Foo&gt;(prefab);

<span class="pl-c">// Add a new component to an existing game object</span>
Foo foo = Container.InstantiateComponent&lt;Foo&gt;(gameObject);
</pre></div>

<h2>
<a id="user-content-further-help" class="anchor" href="#further-help" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-further-help"></a>Further Help</h2>

<p>For general troubleshooting / support, please use the <a href="http://www.reddit.com/r/zenject">zenject subreddit</a> or the <a href="https://groups.google.com/forum/#%21forum/zenject/">zenject google group</a>.  If you have found a bug, you are also welcome to create an issue on the <a href="https://github.com/modesttree/Zenject">github page</a>, or a pull request if you have a fix / extension.  You can also follow <a href="https://twitter.com/Zenject">@Zenject</a> on twitter for updates.  Finally, you can also email me directly at <a href="mailto:sfvermeulen@gmail.com">sfvermeulen@gmail.com</a></p>

<h2>
<a id="user-content-release-notes" class="anchor" href="#release-notes" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-release-notes"></a>Release Notes</h2>

<p>3.7 (Jan 31, 2015)</p>

<ul>
<li>Changed to not both parenting transforms to the CompositionRoot 
object by default (This is still optional with a checkbox however)</li>
<li>Added string parameter to BindGameObjectFactory method to allow 
specifying the name of an empty GameObject to use for organization</li>
<li>Changed FacadeFactory to inherit from IFactory</li>
<li>Changed GlobalCompositionRoot to initialize using Unity's new [RuntimeInitializeOnLoadMethod] attribute</li>
<li>Added easier ability to validate specific scenes from the command line outside of Unity</li>
<li>Added AutoBindInstaller class and ZenjectAutoBinding attribute to 
make it easier to add MonoBehaviours that start in the scene to the 
container</li>
<li>Added optional parameter to the [Inject] attribute to specify which container to retrieve from in the case of nested containers</li>
<li>Fixed some unity-specific bind commands to place more nicely with interfaces</li>
</ul>

<p>3.6 (Jan 24, 2015)</p>

<ul>
<li>Another change to signals to not require parameter types to the bind methods</li>
</ul>

<p>3.5 (Jan 17, 2015)</p>

<ul>
<li>Made breaking change to require separate bind commands for signals and triggers, to allow adding different conditionals on each.</li>
</ul>

<p>3.4 (Jan 7, 2015)</p>

<ul>
<li>Cleaned up directory structure</li>
<li>Fixed bug with Global bindings not getting their Tick() called in the correct order</li>
<li>Fixes to the releases automation scripts</li>
</ul>

<p>3.2 (December 20, 2015)</p>

<ul>
<li>Added the concept of "Commands" and "Signals".  See documentation for details.</li>
<li>Fixed validation for decorator scenes that open decorator scenes.</li>
<li>Changed to be more strict when using a combination of differents 
kinds of ToSingle&lt;&gt;, since there should only be one way to create 
the singleton.</li>
<li>Added ToSingleFactory bind method, for cases where you have complex 
construction requirements and don't want to use ToSingleMethod</li>
<li>Removed the InjectFullScene flag on SceneCompositionRoot.  Now always injects on the full scene.</li>
<li>Renamed AllowNullBindings to IsValidating so it can be used for other kinds of validation-only logic</li>
<li>Renamed BinderUntyped to UntypedBinder and BinderGeneric to GenericBinder</li>
<li>Added the ability to install MonoInstaller's directly from inside 
other installers by calling Container.Install().  In this case it tries 
to load a prefab from Resources/Installers/MyCustomMonoInstaller.prefab 
before giving up.  This can be helpful to keep scenes incredibly small 
instead of having many installer prefabs.</li>
<li>Added the ability to install MonoInstaller's directly from inside 
other installers.  In this case it tries to load a prefab from the 
resources directory before giving up.</li>
<li>Added some better error output in a few places</li>
<li>Fixed some iOS AOT issues</li>
<li>Added BindFacade&lt;&gt; method to DiContainer, to allow creating nested containers without needing to use a factory.</li>
<li>Added an Open button in scene decorator comp root for easily jumping to the decorated scene</li>
<li>Removed support for object graph visualization since I hadn't bothered maintaining it</li>
<li>Got the optional Moq extension method ToMock() working again</li>
<li>Fixed scene decorators to play more nicely with Unity's own way of 
handling LoadLevelAdditive.  Decorated scenes are now organized in the 
scene heirarchy under scene headings just like when calling 
LoadLevelAdditive normally</li>
</ul>

<p>3.1</p>

<ul>
<li>Changes related to upgrading to Unity 5.3</li>
<li>Fixed again to make zero heap allocations per frame</li>
</ul>

<p>3.0</p>

<ul>
<li>Added much better support for nested containers.  It now works more 
closely to what you might expect:  Any parent dependencies are always 
inherited in sub-containers, even for optional injectables.  Also 
removed BindScope and FallbackContainer since these were really just 
workarounds for this feature missing.  Also added [InjectLocal] 
attribute for cases where you want to inject dependencies only from the 
local container.</li>
<li>Changed the way execution order is specified in the installers.  Now
 the order for Initialize / Tick / Dispose are all given by one property
 similar to how unity does it, using ExecutionOrderInstaller</li>
<li>Added ability to pass arguments to Container.Install&lt;&gt;</li>
<li>Added support for using Facade pattern in combination with nested 
containers to allow easily created distinct 'islands' of dependencies.  
See documentation for details</li>
<li>Changed validation to be executed on DiContainer instead of through BindingValidator for ease of use</li>
<li>Added automatic support for WebGL by marking constructors as [Inject]</li>
</ul>

<p>2.8</p>

<ul>
<li>Fixed to properly use explicit default parameter values in 
Constructor/PostInject methods.  For eg: public Foo(int bar = 5) should 
consider bar to be optional and use 5 if not resolved.</li>
</ul>

<p>2.7</p>

<ul>
<li>Bug fix to ensure global composition root always gets initialized before the scene composition root</li>
<li>Changed scene decorators to use LoadLevelAdditive instead of 
LoadLevel to allow more complex setups involving potentially several 
decorators within decorators</li>
</ul>

<p>2.6</p>

<ul>
<li>Added new bind methods: ToResource, ToTransientPrefabResource, ToSinglePrefabResource</li>
<li>Added ability to have multiple sets of global installers</li>
<li>Fixed support for using zenject with .NET 4.5</li>
<li>Created abstract base class CompositionRoot for both SceneCompositionRoot and GlobalCompositionRoot</li>
<li>Better support for using the same DiContainer from multiple threads</li>
<li>Added back custom list inspector handler to make it easier to re-arrange etc.</li>
<li>Removed the extension methods on DiContainer to avoid a gotcha that occurs when not including 'using Zenject</li>
<li>Changed to allow having a null root transform given to DiContainer</li>
<li>Changed to assume any parameters with hard coded default values (eg: int x = 5) are InjectOptional</li>
<li>Fixed bug with asteroids project which was causing exceptions to be thrown on the second run due to the use of tags</li>
</ul>

<p>2.5</p>

<ul>
<li>Added support for circular dependencies in the PostInject method or as fields (just not constructor parameters)</li>
<li>Fixed issue with identifiers that was occurring when having both 
[Inject] and [InjectOptional] attributes on a field/constructor 
parameter.  Now requires that only one be set</li>
<li>Removed BindValue in favour of just using Bind for both reference and value types for simplicity</li>
<li>Removed GameObjectInstantiator class since it was pretty awkward and
 confusing.  Moved methods directly into IInstantiator/DiContainer.  See
 IInstantiator class.</li>
<li>Extracted IResolver and IBinder interfaces from DiContainer</li>
</ul>

<p>2.4</p>

<ul>
<li>Refactored the way IFactory is used to be a lot cleaner. It now uses
 a kind of fluent syntax through its own bind method 
BindIFactory&lt;&gt;</li>
</ul>

<p>2.3</p>

<ul>
<li>Added "ParentContexts" property to InjectContext, to allow very 
complex conditional bindings that involve potentially several 
identifiers, etc.</li>
<li>Removed InjectionHelper class and moved methods into DiContainer to simplify API and also to be more discoverable</li>
<li>Added ability to build dlls for use in outside unity from the assembly build solution</li>
</ul>

<p>2.2</p>

<ul>
<li>Changed the way installers invoke other installers.  Previously you 
would Bind them to IInstaller and now you call Container.Install 
instead.  This is better because it allows you to immediately call 
Rebind&lt;&gt; afterwards</li>
</ul>

<p>2.1</p>

<ul>
<li>Simplified interface a bit more by moving more methods into 
DiContainer such as Inject and Instantiate.  Moved all helper methods 
into extension methods for readability. Deleted FieldsInjector and 
Instantiator classes as part of this</li>
<li>Renamed DiContainer.To() method to ToInstance since I had witnessed 
some confusion with it for new users.  Did the same with 
ToSingleInstance</li>
<li>Added support for using Zenject outside of Unity by building with the ZEN_NOT_UNITY3D define set</li>
<li>Bug fix - Validation was not working in some cases for prefabs.</li>
<li>Renamed some of the parameters in InjectContext for better understandability.</li>
<li>Renamed DiContainer.ResolveMany to DiContainer.ResolveAll</li>
<li>Added 'InjectFullScene' flag to CompositionRoot to allow injecting 
across the entire unity scene instead of just objects underneath the 
CompositionRoot</li>
</ul>

<p>2.0</p>

<ul>
<li>Added ability to inject dependencies via parameters to the 
[PostInject] method just like it does with constructors.  Especially 
useful for MonoBehaviours.</li>
<li>Fixed the order that [PostInject] methods are called in for prefabs</li>
<li>Changed singletons created via ToSinglePrefab to identify based on 
identifier and prefab and not component type. This allows things like 
ToSingle(prefab1) and ToSingle(prefab1) to use the same prefab, so you 
can map singletons to multiple components on the same prefab. This also 
works with interfaces.</li>
<li>Removed '.As()' method in favour of specifying the identifier in the first Bind() statement</li>
<li>Changed identifiers to be strings instead of object to avoid accidental usage</li>
<li>Renamed ToSingle(obj) to ToSingleInstance to avoid conflict with specifying an identifier</li>
<li>Fixed validation to work properly for ToSinglePrefab</li>
<li>Changed to allow using conditions to override a default binding. 
When multiple providers are found it will now try and use the one with 
conditions.  So for example you can define a default with <code>Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo1&gt;()</code> and then override for specific classes with <code>Container.Bind&lt;IFoo&gt;().ToSingle&lt;Foo2&gt;().WhenInjectedInto&lt;Bar&gt;()</code>, etc.</li>
</ul>

<p>1.19</p>

<ul>
<li>Upgraded to Unity 5</li>
<li>Added an optional identifier to InjectOptional attribute</li>
<li>Changed the way priorities are interpreted for tickables, 
disposables, etc. Zero is now used as default for any unspecified 
priorities.  This is helpful because it allows you to choose priorities 
that occur either before or after the unspecified priorities.</li>
<li>Added some helper methods to ZenEditorUtil for use by CI servers to validate all scenes</li>
</ul>

<p>1.18</p>

<ul>
<li>Added minor optimizations to reduce per-frame allocation to zero</li>
<li>Fixed unit tests to be compatible with unity test tools</li>
<li>Minor bug fix with scene decorators, GameObjectInstantiator.</li>
</ul>

<p>1.17</p>

<ul>
<li>Bug fix.  Was not forwarding parameters correctly when instantiating objects from prefabs</li>
</ul>

<p>1.16</p>

<ul>
<li>Removed the word 'ModestTree' from namespaces since Zenject is open source and not proprietary to the company ModestTree.</li>
</ul>

<p>1.15</p>

<ul>
<li>Fixed bug with ToSinglePrefab which was causing it to create multiple instances when used in different bindings.</li>
</ul>

<p>1.14</p>

<ul>
<li>Added flag to CompositionRoot for whether to inject into inactive game objects or ignore them completely</li>
<li>Added BindAllInterfacesToSingle method to DiContainer</li>
<li>Changed to call PostInject[] on children first when instantiating from prefab</li>
<li>Added ILateTickable interface, which works just like ITickable or IFixedTickable for unity's LateUpdate event</li>
<li>Added support for 'decorators', which can be used to add dependencies to another scene</li>
</ul>

<p>1.13</p>

<ul>
<li>Minor bug fix to global composition root.  Also fixed a few compiler warnings.</li>
</ul>

<p>1.12</p>

<ul>
<li>Added Rebind&lt;&gt; method</li>
<li>Changed Factories to use strongly typed parameters by default.  Also
 added ability to pass in null values as arguments as well as multiple 
instances of the same type</li>
<li>Renamed _container to Container in the installers</li>
<li>Added support for Global Composition Root to allow project-wide installers/bindings</li>
<li>Added DiContainer.ToSingleMonoBehaviour method</li>
<li>Changed to always include the StandardUnityInstaller in the CompositionRoot class.</li>
<li>Changed TickableManager to not be a monobehaviour and receive its update from the UnityDependencyRoot instead</li>
<li>Added IFixedTickable class to support unity FixedUpdate method</li>
</ul>

<p>1.11</p>

<ul>
<li>Removed Fasterflect library to keep Zenject nice and lightweight (it was also causing issues on WP8)</li>
<li>Fixed bug related to singletons + object graph validation. Changed 
the way IDisposables are handled to be closer to the way IInitializable 
and ITickable are handled. Added method to BinderUntyped.</li>
</ul>

<p>1.10</p>

<ul>
<li>Added custom editor for the Installers property of CompositionRoot to make re-ordering easier</li>
</ul>

<p>1.09</p>

<ul>
<li>Added support for nested containers</li>
<li>Added ability to execute bind commands using Type objects rather than a generic type</li>
<li>Changed the way IDisposable bindings work to be similar to how ITickable and IInitializable work</li>
<li>Bug fixes</li>
</ul>

<p>1.08</p>

<ul>
<li>Order of magnitude speed improvement by using more caching</li>
<li>Minor change to API to use the As() method to specify identifiers</li>
<li>Bug fixes</li>
</ul>

<p>1.07</p>

<ul>
<li>Simplified API by removing the concept of modules in favour of just 
having installers instead (and add support for installers installing 
other installers)</li>
<li>Bug fixes</li>
</ul>

<p>1.06</p>

<ul>
<li>Introduced concept of scene installer, renamed installers 'modules'</li>
<li>Bug fixes</li>
</ul>

<h2>
<a id="user-content-license" class="anchor" href="#license" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><a id="user-content-license"></a>License</h2>

<pre><code>The MIT License (MIT)

Copyright (c) 2010-2015 Modest Tree Media  http://www.modesttree.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</code></pre>

              </div>
            </div>
          </div>
        

      </div>
    </div>
  </div>
  <div>&nbsp;</div>
  </div><script>
    function showCanonicalImages() {
      var images = document.getElementsByTagName('img');
      if (!images) {
        return;
      }
      for (var index = 0; index < images.length; index++) {
        var image = images[index];
        if (image.getAttribute('data-canonical-src') && image.src !== image.getAttribute('data-canonical-src')) {
          image.src = image.getAttribute('data-canonical-src');
        }
      }
    }

    function scrollToHash() {
      if (location.hash && !document.querySelector(':target')) {
        var element = document.getElementById('user-content-' + location.hash.slice(1));
        if (element) {
           element.scrollIntoView();
        }
      }
    }

    function autorefreshContent(eventSourceUrl) {
      var initialTitle = document.title;
      var contentElement = document.getElementById('grip-content');
      var source = new EventSource(eventSourceUrl);
      var isRendering = false;

      source.onmessage = function(ev) {
        var msg = JSON.parse(ev.data);
        if (msg.updating) {
          isRendering = true;
          document.title = '(Rendering) ' + document.title;
        } else {
          isRendering = false;
          document.title = initialTitle;
          contentElement.innerHTML = msg.content;
          showCanonicalImages();
        }
      }

      source.onerror = function(e) {
        if (e.readyState === EventSource.CLOSED && isRendering) {
          isRendering = false;
          document.title = initialTitle;
        }
      }
    }

    window.onhashchange = function() {
      scrollToHash();
    }

    window.onload = function() {
      scrollToHash();
    }

    showCanonicalImages();

    var autorefreshUrl = document.getElementById('preview-page').getAttribute('data-autorefresh-url');
    if (autorefreshUrl) {
      autorefreshContent(autorefreshUrl);
    }
  </script>

</body></html>